// -*- mode:c++ -*-

// Copyright (c) 2015 RISC-V Foundation
// Copyright (c) 2016 The University of Virginia
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////
//
// Calls operation instructions : call, return, retseal
//
def format Calls(code, *opt_flags) {{
    regs = ['srcRegIdx(0)', 'srcRegIdx(1)']
    iop = InstObjParams(name, Name, 'CallsClass',
           {'code': code, 'regs': ','.join(regs)},
            opt_flags)
    header_output = CallsDeclare.subst(iop)
    decoder_output = CallsConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = CallsExecute.subst(iop) + \
        CallsCompleteAcc.subst(iop)
}};

def template CallsDeclare {{
    static constexpr uint64_t CONTEXT_SIZE = NumIntArchRegs * sizeof(RegVal); // in bytes
    static constexpr uint64_t REQUEST_N = CONTEXT_SIZE / MAX_REQUEST_SIZE;
    /**
     * Static instruction class for "%(mnemonic)s".
     */
    class %(class_name)s : public %(base_class)s
    {
    
        private:
            RegId srcRegIdxArr[NumIntArchRegs]; RegId destRegIdxArr[NumIntArchRegs];

        public:
        /// Constructor.
        %(class_name)s(ExtMachInst machInst);

        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext*, Trace::InstRecord*) const override;
    };
}};

def template CallsConstructor {{
    %(class_name)s::%(class_name)s(ExtMachInst machInst):
        %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        setRegIdxArrays(
            reinterpret_cast<RegIdArrayPtr>(
                &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
            reinterpret_cast<RegIdArrayPtr>(
                &std::remove_pointer_t<decltype(this)>::destRegIdxArr));

        for(int i = 1; i < NumIntArchRegs; i ++) {
            setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, i));
            setDestRegIdx(_numDestRegs++, RegId(IntRegClass, i));
        }
        
        %(constructor)s;

        flags[IsInteger] = true;
        flags[IsLoad] = true;
        // flags[IsStore] = true;
        flags[IsStore] = false;
        hasNodeOp = true;
    }
}};

def template CallsExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* inst = dynamic_cast<DynInst*>(xc);
        assert(inst);

        ConstTaggedRegVal Rs1, Rd;

        int Rs1_src_idx = RS1 - 1;
        int Rd_src_idx = RD - 1;

        if (Rs1_src_idx >= 0)
        {
            Rs1 = inst->getTaggedRegOperand(this, Rs1_src_idx);
        }

        if (Rd_src_idx >= 0)
        {
            Rd = inst->getTaggedRegOperand(this, Rd_src_idx);
        }

        if(!Rs1.getTag()) {
            return std::make_shared<IllegalInstFault>("Operand needs to be a capability", machInst);
        }
        
        const Cap& Rs1_cap = Rs1.getRegVal().capVal();
        
        if(Rs1_cap.type() != CapType::SEALED) {
            return std::make_shared<IllegalInstFault>("Operand can only be a sealed capability", machInst);
        }
        
        if(Rs1_cap.perm() == CapPerm::NA) {
            return std::make_shared<IllegalInstFault>("Operation not permitted with the given capability", machInst);
        }
        
        uint64_t base_addr = Rs1_cap.start();
        uint64_t end_addr = Rs1_cap.end();
        assert(end_addr >= base_addr);
        uint64_t len = end_addr - base_addr;
        
        if(len < CONTEXT_SIZE) {
            return std::make_shared<IllegalInstFault>("Memory region too small for a domain context", machInst);
        }

        Fault fault = inst->initiateNodeCommand(new NodeQuery(Rs1_cap.nodeId()));
        if(fault != NoFault) {
            return fault;
        }
        
        DPRINTFN("Call checks passed\n");
        
        uint64_t cur_addr = base_addr;
        
        // uint8_t dummy[MAX_REQUEST_SIZE];
        RegVal dummy;
        // for(int i = 0; i < REQUEST_N; i ++, cur_addr += MAX_REQUEST_SIZE) {
        //     initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
        // }
        for(int i = 0; i < NumIntArchRegs; i ++, cur_addr += sizeof(RegVal)) {
            initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
        }
        
        for(cur_addr = base_addr; cur_addr < base_addr + CONTEXT_SIZE; cur_addr += sizeof(RegVal)) {
            inst->initiateGetTag(cur_addr);
        }
        
        return NoFault;
    }
}};

def template CallsCompleteAcc {{
    Fault
    %(class_name)s::completeAcc(PacketPtr pkt, ExecContext* xc, Trace::InstRecord* traceData) const {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* inst = dynamic_cast<DynInst*>(xc);
        assert(inst);
        assert(inst->memReadN == NumIntArchRegs);
        
        RiscvcapstoneISAInst::PCState pc_state;
        set(pc_state, xc->pcState());
        uint64_t npc = pc_state.npc();
        Cap pc_cap = inst->cpu->getIEWObject().getPCCap(inst->threadNumber);
        pc_cap.setCursor(npc); // prepare the PC cap to save
        
        for(int reg_idx = 0; reg_idx < NumIntArchRegs; reg_idx ++) {
            RegVal& v = *(RegVal*)(inst->getMemReadRes(reg_idx));
            ConstTagRef tag = inst->getTagQueryRes(reg_idx);
            DPRINTFN("Reg %d  = 0x%llx (tag = %d)\n",
                reg_idx, v.intVal(), tag);
            
            // write back to registers
            if(reg_idx == 0) {
                assert(tag);
                pc_state.npc(v.capVal().cursor());
                inst->cpu->getIEWObject().setPCCap(v.capVal(),
                                               inst->threadNumber);

            } else {
                ConstTaggedRegVal tagged_val(v, tag);
                inst->setTaggedRegOperand(this, reg_idx, tagged_val);
            }
        }
        xc->pcState(pc_state);
        
        
        ConstTaggedRegVal Rs1, Rd;

        int Rs1_src_idx = RS1 - 1;
        int Rd_src_idx = RD - 1;

        if (Rs1_src_idx >= 0)
        {
            Rs1 = inst->getTaggedRegOperand(this, Rs1_src_idx);
        }

        if (Rd_src_idx >= 0)
        {
            Rd = inst->getTaggedRegOperand(this, Rd_src_idx);
        }

        const Cap& Rs1_cap = Rs1.getRegVal().capVal();
        uint64_t base_addr = Rs1_cap.start();
        
        // TODO: save context
        // save PC cap
        // no need to change tag as we already know it is tagged
        // TODO: optimisation: write multiple regs at one time
        // Fault fault = writeMemTimingLE(xc, traceData, RegVal(pc_cap), base_addr,
        //     Request::Flags(), nullptr);
        // if(fault != NoFault) {
        //     return fault;
        // }

        // uint64_t cur_addr = base_addr + sizeof(RegVal);

        // for(int i = 1; i < NumIntArchRegs; i ++, cur_addr += sizeof(RegVal)) {
        //     ConstTaggedRegVal v = inst->getTaggedRegOperand(this, i);
        //     // store value
        //     fault = writeMemTimingLE(xc, traceData, v.getRegVal(), cur_addr, 
        //         Request::Flags(), nullptr);
        //     if(fault != NoFault) {
        //         return fault;
        //     }
        //     // store tag
        //     fault = inst->initiateSetTag(cur_addr, v.getTag());
        // }

        // TODO: seal
        // TODO: update ref counts


        return NoFault;
    }

}};
