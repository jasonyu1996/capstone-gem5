// -*- mode:c++ -*-

//Revoke
def template TestRevokeExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestRevokeInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        return dyn_inst->initiateNodeCommand(new NodeRevoke(node_id));
    }
}};

def template TestRevokeCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//Query
def template TestQueryExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestQueryInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        return dyn_inst->initiateNodeCommand(new NodeQuery(node_id));
    }
}};

def template TestQueryCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//RcUpdate
def template TestRcUpdateExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestRcUpdateInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        DPRINTFN("Test RcUpdate node_id = %u\n", node_id);
        int delta = static_cast<int>(xc->getRegOperand(this, 1));
        DPRINTFN("delta = %u\n", delta);
        return dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, delta));
    }
}};

def template TestRcUpdateCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//Alloc
def template TestAllocExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestAllocInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {

        using namespace gem5::RiscvcapstoneISA::o3;

        DPRINTFN("Testalloc parent id = %lu\n", xc->getRegOperand(this, 0));

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        
        auto& node_controller = dyn_inst->getNodeController();
        NodeID to_allocate = node_controller.tryAllocate();

        xc->setRegOperand(this, 0, to_allocate);

        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        return dyn_inst->initiateNodeCommand(new NodeAllocate(node_id, to_allocate));
    }
}};

def template TestAllocCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        //using namespace gem5::RiscvcapstoneISA::o3;

        //auto allocate_cmd = dynamic_cast<NodeAllocate*>(cmd);
        //assert(allocate_cmd);

        //DPRINTFN("Testalloc finished with alloc id = %u\n",
                //static_cast<unsigned int>(allocate_cmd->getAllocatedID()));

        //xc->setRegOperand(this, 0, allocate_cmd->getAllocatedID());

        return NoFault;
    }
}};

//Drop
def template TestDropExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestDropInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        DPRINTFN("Test Drop node_id = %u\n", node_id);
        return dyn_inst->initiateNodeCommand(new NodeDrop(node_id));
    }
}};

def template TestDropCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};


def template TestInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        %(op_decl)s;
        %(op_rd)s;

        %(initiate_node_acc_code)s;

        %(op_wb)s;

        return NoFault;
    }
}};


def template TestCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        %(complete_node_acc_code)s;

        return NoFault;
    }
}};

def template TestExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        %(code)s;
        return NoFault;
    }
}};




