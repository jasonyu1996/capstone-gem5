// -*- mode:c++ -*-

//Revoke
def template TestRevokeExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestRevokeInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        const RegId regId = srcRegIdx(0);
        const RegIndex regIdx = regId.index();

        ThreadContext *tcBase = xc->tcBase();
        int threadId = tcBase->threadId();

        gem5::RiscvcapstoneISA::o3::DynInst *dyn_inst =
                dynamic_cast<gem5::RiscvcapstoneISA::o3::DynInst *>(xc);

        gem5::RiscvcapstoneISA::CapLoc regLoc =
                    gem5::RiscvcapstoneISA::CapLoc::makeReg(threadId, regIdx);

        /* TODO: Add actual method to retrieve node ID from the capability */
        gem5::RiscvcapstoneISA::NodeID nodeId = 0;

        gem5::RiscvcapstoneISA::o3::NodeRevoke qry =
                    gem5::RiscvcapstoneISA::o3::NodeRevoke(dyn_inst, nodeId);

        gem5::RiscvcapstoneISA::o3::NodeCommandPtr cmd = &qry;

        auto o3cpu = dynamic_cast<gem5::RiscvcapstoneISA::o3::CPU *>(cpu);

        o3cpu->pushNodeCommand(dyn_inst, cmd);

        return NoFault;
    }
}};

def template TestRevokeCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//Query
def template TestQueryExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestQueryInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        return dyn_inst->initiateNodeCommand(new NodeQuery(node_id));
    }
}};

def template TestQueryCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//RcUpdate
def template TestRcUpdateExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestRcUpdateInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        using namespace gem5::RiscvcapstoneISA::o3;

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        DPRINTFN("Test RcUpdate node_id = %u\n", node_id);
        int delta = static_cast<int>(xc->getRegOperand(this, 1));
        DPRINTFN("delta = %u\n", delta);
        return dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, delta));
    }
}};

def template TestRcUpdateCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//Alloc
def template TestAllocExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestAllocInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {

        using namespace gem5::RiscvcapstoneISA::o3;

        DPRINTFN("Testalloc parent id = %lu\n", xc->getRegOperand(this, 0));

        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
        assert(dyn_inst);
        /* TODO: Add actual method to retrieve node ID from the capability */
        NodeID node_id = static_cast<NodeID>(xc->getRegOperand(this, 0));
        return dyn_inst->initiateNodeCommand(new NodeAllocate(node_id));
    }
}};

def template TestAllocCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

//Drop
def template TestDropExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def template TestDropInitiateAcc {{
    Fault
    %(class_name)s::initiateNodeAcc(ExecContext *xc, BaseCPU *cpu,
        Trace::InstRecord *traceData) const
    {
        //TODO: Add code once Jason updates code for the class
        return NoFault;
    }
}};

def template TestDropCompleteAcc {{
    Fault
    %(class_name)s::completeNodeAcc(ExecContext *xc, BaseCPU *cpu,
        gem5::RiscvcapstoneISA::o3::NodeCommand *cmd,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};
