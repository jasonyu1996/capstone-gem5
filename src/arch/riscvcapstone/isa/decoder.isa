// -*- mode:c++ -*-

// Copyright (c) 2015 RISC-V Foundation
// Copyright (c) 2017 The University of Virginia
// Copyright (c) 2020 Barkhausen Institut
// Copyright (c) 2021 StreamComputing Corp
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////
//
// The RISC-V ISA decoder
//

decode QUADRANT default Unknown::unknown() {
    0x0: decode COPCODE {
        0x0: CIAddi4spnOp::c_addi4spn({{
            imm = CIMM8<1:1> << 2 |
                  CIMM8<0:0> << 3 |
                  CIMM8<7:6> << 4 |
                  CIMM8<5:2> << 6;
        }}, {{
            if (machInst == 0)
                return std::make_shared<IllegalInstFault>("zero instruction",
                                                           machInst);
            Rp2 = sp + imm;
        }}, uint64_t);
        format CompressedLoad {
            0x1: c_fld({{
                offset = CIMM3 << 3 | CIMM2 << 6;
            }}, {{
                STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                if (status.fs == FPUStatus::OFF)
                    return std::make_shared<IllegalInstFault>("FPU is off",
                                                               machInst);

                Fp2_bits = Mem;
            }}, {{
                EA = Rp1 + offset;
            }});
            0x2: c_lw({{
                offset = CIMM2<1:1> << 2 |
                         CIMM3 << 3 |
                         CIMM2<0:0> << 6;
            }}, {{
                Rp2_sd = Mem_sw;
            }}, {{
                EA = Rp1 + offset;
            }});
            0x3: c_ld({{
                offset = CIMM3 << 3 | CIMM2 << 6;
            }}, {{
                Rp2_sd = Mem_sd;
            }}, {{
                EA = Rp1 + offset;
            }});
        }
        format CompressedStore {
            0x5: c_fsd({{
                offset = CIMM3 << 3 | CIMM2 << 6;
            }}, {{
                STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                if (status.fs == FPUStatus::OFF)
                    return std::make_shared<IllegalInstFault>("FPU is off",
                                                               machInst);

                Mem = Fp2_bits;
            }}, {{
                EA = Rp1 + offset;
            }});
            0x6: c_sw({{
                offset = CIMM2<1:1> << 2 |
                         CIMM3 << 3 |
                         CIMM2<0:0> << 6;
            }}, {{
                Mem_uw = Rp2_uw;
            }}, ea_code={{
                EA = Rp1 + offset;
            }});
            0x7: c_sd({{
                offset = CIMM3 << 3 | CIMM2 << 6;
            }}, {{
                    Mem_ud = Rp2_ud;
            }}, {{
                EA = Rp1 + offset;
            }});
        }
    }
    0x1: decode COPCODE {
        format CIOp {
            0x0: c_addi({{
                imm = CIMM5;
                if (CIMM1 > 0)
                    imm |= ~((uint64_t)0x1F);
            }}, {{
                if ((RC1 == 0) != (imm == 0)) {
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    } else { // imm == 0
                        return std::make_shared<IllegalInstFault>(
                                "immediate = 0", machInst);
                    }
                }
                using namespace gem5::RiscvcapstoneISA::o3;

                DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                assert(dyn_inst);

                if(Rc1_trv.getTag()) {
                    Rc1_trv.setTag(false);
                    NodeID node_id = Rc1_trv.getRegVal().capVal().nodeId();
                    dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, -1));
                }

                int64_t tmp = Rc1_trv.getRegVal().intVal();
                tmp = tmp + imm;
                Rc1_trv.getRegVal().intVal() = tmp;
                Rc1_trv = Rc1_trv;
            }});
            0x1: c_addiw({{
                imm = CIMM5;
                if (CIMM1 > 0)
                    imm |= ~((uint64_t)0x1F);
            }}, {{
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1_sw = (int32_t)(Rc1_sw + imm);
            }});
            0x2: c_li({{
                imm = CIMM5;
                if (CIMM1 > 0)
                    imm |= ~((uint64_t)0x1F);
            }}, {{
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }

                using namespace gem5::RiscvcapstoneISA::o3;

                DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                assert(dyn_inst);

                if(Rc1_trv.getTag()) {
                    Rc1_trv.setTag(false);
                    NodeID node_id = Rc1_trv.getRegVal().capVal().nodeId();
                    dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, -1));
                }

                Rc1_trv.getRegVal().intVal() = imm;
                Rc1_trv = Rc1_trv;
            }});
            0x3: decode RC1 {
                0x2: c_addi16sp({{
                    imm = CIMM5<4:4> << 4 |
                          CIMM5<0:0> << 5 |
                          CIMM5<3:3> << 6 |
                          CIMM5<2:1> << 7;
                    if (CIMM1 > 0)
                        imm |= ~((int64_t)0x1FF);
                }}, {{
                    if (imm == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "immediate = 0", machInst);
                    }
                    sp_sd = sp_sd + imm;
                }});
                default: c_lui({{
                    imm = CIMM5 << 12;
                    if (CIMM1 > 0)
                        imm |= ~((uint64_t)0x1FFFF);
                }}, {{
                    if (RC1 == 0 || RC1 == 2) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    if (imm == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "immediate = 0", machInst);
                    }
                    using namespace gem5::RiscvcapstoneISA::o3;

                    DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                    assert(dyn_inst);

                    if(Rc1_trv.getTag()) {
                        Rc1_trv.setTag(false);
                        NodeID node_id = Rc1_trv.getRegVal().capVal().nodeId();
                        dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, -1));
                    }

                    Rc1_trv.getRegVal().intVal() = imm;
                    Rc1_trv = Rc1_trv;
                }});
            }
        }
        0x4: decode CFUNCT2HIGH {
            format CIOp {
                0x0: c_srli({{
                    imm = CIMM5 | (CIMM1 << 5);
                }}, {{
                    if (imm == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "immediate = 0", machInst);
                    }
                    Rp1 = Rp1 >> imm;
                }}, uint64_t);
                0x1: c_srai({{
                    imm = CIMM5 | (CIMM1 << 5);
                }}, {{
                    if (imm == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "immediate = 0", machInst);
                    }
                    Rp1_sd = Rp1_sd >> imm;
                }}, uint64_t);
                0x2: c_andi({{
                    imm = CIMM5;
                    if (CIMM1 > 0)
                        imm |= ~((uint64_t)0x1F);
                }}, {{
                    Rp1 = Rp1 & imm;
                }}, uint64_t);
            }
            format CompressedROp {
                0x3: decode CFUNCT1 {
                    0x0: decode CFUNCT2LOW {
                        0x0: c_sub({{
                            Rp1 = Rp1 - Rp2;
                        }});
                        0x1: c_xor({{
                            Rp1 = Rp1 ^ Rp2;
                        }});
                        0x2: c_or({{
                            Rp1 = Rp1 | Rp2;
                        }});
                        0x3: c_and({{
                            Rp1 = Rp1 & Rp2;
                        }});
                    }
                    0x1: decode CFUNCT2LOW {
                        0x0: c_subw({{
                            Rp1_sd = (int32_t)Rp1_sd - Rp2_sw;
                        }});
                        0x1: c_addw({{
                            Rp1_sd = (int32_t)Rp1_sd + Rp2_sw;
                        }});
                    }
                }
            }
        }
        0x5: CJOp::c_j({{
            NPC = PC + imm;
        }}, IsDirectControl, IsUncondControl);
        format CBOp {
            0x6: c_beqz({{
                if (Rp1 == 0)
                    NPC = PC + imm;
                else
                    NPC = NPC;
            }}, IsDirectControl, IsCondControl);
            0x7: c_bnez({{
                if (Rp1 != 0)
                    NPC = PC + imm;
                else
                    NPC = NPC;
            }}, IsDirectControl, IsCondControl);
        }
    }
    0x2: decode COPCODE {
        0x0: CIOp::c_slli({{
            imm = CIMM5 | (CIMM1 << 5);
        }}, {{
            if (imm == 0) {
                return std::make_shared<IllegalInstFault>(
                        "immediate = 0", machInst);
            }
            if (RC1 == 0) {
                return std::make_shared<IllegalInstFault>(
                        "source reg x0", machInst);
            }
            Rc1 = Rc1 << imm;
        }}, uint64_t);
        format CompressedLoad {
            0x1: c_fldsp({{
                offset = CIMM5<4:3> << 3 |
                         CIMM1 << 5 |
                         CIMM5<2:0> << 6;
            }}, {{
                Fc1_bits = Mem;
            }}, {{
                EA = sp + offset;
            }});
            0x2: c_lwsp({{
                offset = CIMM5<4:2> << 2 |
                         CIMM1 << 5 |
                         CIMM5<1:0> << 6;
            }}, {{
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1_sd = Mem_sw;
            }}, {{
                EA = sp + offset;
            }});
            0x3: c_ldsp({{
                offset = CIMM5<4:3> << 3 |
                         CIMM1 << 5 |
                         CIMM5<2:0> << 6;
            }}, {{
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1_sd = Mem_sd;
            }}, {{
                EA = sp + offset;
            }});
        }
        0x4: decode CFUNCT1 {
            0x0: decode RC2 {
                0x0: Jump::c_jr({{
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    NPC = Rc1;
                }}, IsIndirectControl, IsUncondControl);
                default: CROp::c_mv({{
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    Rc1 = Rc2;
                }});
            }
            0x1: decode RC1 {
                0x0: SystemOp::c_ebreak({{
                    if (RC2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    return std::make_shared<BreakpointFault>(xc->pcState());
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                default: decode RC2 {
                    0x0: Jump::c_jalr({{
                        if (RC1 == 0) {
                            return std::make_shared<IllegalInstFault>(
                                    "source reg x0", machInst);
                        }
                        ra = NPC;
                        NPC = Rc1;
                    }}, IsIndirectControl, IsUncondControl, IsCall);
                    default: CompressedROp::c_add({{
                        Rc1_sd = Rc1_sd + Rc2_sd;
                    }});
                }
            }
        }
        format CompressedStore {
            0x5: c_fsdsp({{
                offset = CIMM6<5:3> << 3 |
                         CIMM6<2:0> << 6;
            }}, {{
                Mem_ud = Fc2_bits;
            }}, {{
                EA = sp + offset;
            }});
            0x6: c_swsp({{
                offset = CIMM6<5:2> << 2 |
                         CIMM6<1:0> << 6;
            }}, {{
                Mem_uw = Rc2_uw;
            }}, {{
                EA = sp + offset;
            }});
            0x7: c_sdsp({{
                offset = CIMM6<5:3> << 3 |
                         CIMM6<2:0> << 6;
            }}, {{
                Mem = Rc2;
            }}, {{
                EA = sp + offset;
            }});
        }
    }
    0x3: decode OPCODE {
        //Capstone Ops
        0x16: decode FUNCT3 {
            0x1: decode FUNCT7 {
                format ROp {
                    //format CIOp
                    0x4: lcc ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        //todo: there probably be a cleaner way of doing this

                        uint64_t res; bool unexpect = false;
                        Cap cap_val = Rs1_trv.getRegVal().capVal();
                        CapType t = cap_val.type();

                        switch(CIIMM5) {
                            case 0: break; //validity field - query then result?
                            case 1: res = static_cast<uint64_t>(cap_val.type()); break;
                            case 2: if(t == CapType::SEALED) {
                                        unexpect = true;
                                        break;
                                    }
                                    res = cap_val.cursor(); break;
                            case 3: res = cap_val.start(); break;
                            case 4: if(t == CapType::SEALED || t == CapType::SEALEDRET || t == CapType::EXIT) {
                                        unexpect = true;
                                        break;
                                    }
                                    res = cap_val.end(); break;
                            case 5: if(t == CapType::SEALED || t == CapType::SEALEDRET || t == CapType::EXIT) {
                                        unexpect = true;
                                        break;
                                    }
                                    res = static_cast<uint64_t>(cap_val.perm()); break;
                            case 6: if(!(t == CapType::SEALED || t == CapType::SEALEDRET)) {
                                        unexpect = true;
                                        break;
                                    }
                                    res = static_cast<uint64_t>(cap_val.async()); break;
                            case 7: if(t != CapType::SEALEDRET) {
                                        unexpect = true;
                                        break;
                                    }
                                    res = static_cast<uint64_t>(cap_val.reg()); break;
                            default: res = 0;
                        }

                        if(unexpect)
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);

                        //Rd_trv or Rd_ud doesn't matter. Commit will handle Rc update
                        Rd_ud = res;
                    }});
                    0xc: cincoffset ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        DynInst *dyn_inst = dynamic_cast<DynInst *>(xc);
                        assert(dyn_inst);

                        //todo: set Rs1 to cnull
                        if(!(Rs1_trv.getTag() && !Rs2_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(!(rs1_cap.type() != CapType::UNINIT && rs1_cap.type() != CapType::SEALED)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        uint64_t cursor = rs1_cap.cursor();

                        rs1_cap.setCursor(cursor + Rs2_trv.getRegVal().intVal());
                        Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;

                        Rd_trv = Rs1_trv;

                        //movc semantics
                        //rs1 still retains the original cap
                        if(rs1_cap.type() != CapType::NONLIN)
                            Rs1_trv.setTag(false);
                        else {
                            uint64_t node_id = rs1_cap.nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }
                        Rs1_trv = Rs1_trv;
                    }});
                    0x5: scc ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        DynInst *dyn_inst = dynamic_cast<DynInst *>(xc);
                        assert(dyn_inst);

                        //todo: set Rs1 to cnull
                        if(!(Rs1_trv.getTag() && !Rs2_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(!(rs1_cap.type() != CapType::UNINIT && rs1_cap.type() != CapType::SEALED)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        rs1_cap.setCursor(Rs2_trv.getRegVal().intVal());

                        ConstTaggedRegVal temp;
                        temp.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        temp.setTag(true);

                        Rd_trv = temp;

                        //movc semantics
                        //rs1 still retains the original cap
                        if(rs1_cap.type() != CapType::NONLIN)
                            Rs1_trv.setTag(false);
                        else {
                            uint64_t node_id = rs1_cap.nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }
                        Rs1_trv = Rs1_trv;
                    }});
                    0x1: shrink ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!(Rd_trv.getTag() && !Rs1_trv.getTag() && !Rs2_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rd_cap = Rd_trv.getRegVal().capVal();

                        if(!(rd_cap.type() == CapType::LIN || rd_cap.type() == CapType::NONLIN ||
                            rd_cap.type() == CapType::UNINIT)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        uint64_t rs1_v = Rs1_trv.getRegVal().intVal();
                        uint64_t rs2_v = Rs2_trv.getRegVal().intVal();

                        uint64_t start = rd_cap.start();
                        uint64_t end = rd_cap.end();

                        if(!(rs1_v >= start && rs2_v <= end && rs1_v < rs2_v)) {
                            return std::make_shared<IllegalInstFault>("Illegal operand value (29)", machInst);
                        }

                        //maybe don't update the cursor if it's already within bounds?
                        rd_cap.setBound(rs1_v, rs2_v);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv;
                    }});
                    0x3: delin ({{
                        //todo: update captype also in node
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!Rd_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rd_cap = Rd_trv.getRegVal().capVal();

                        if(rd_cap.type() != CapType::LIN) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        rd_cap.setType(CapType::NONLIN);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv;
                    }});
                    0x9: init ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!(Rs1_trv.getTag() && !Rs2_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::UNINIT) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        if(rs1_cap.cursor() != rs1_cap.end()) {
                            return std::make_shared<IllegalInstFault>("Illegal operand value (29)", machInst);
                        }

                        rs1_cap.setType(CapType::LIN);

                        //why not set desired value straight away with Rs2?
                        rs1_cap.setCursor(rs1_cap.start() + Rs2_trv.getRegVal().intVal());
                        Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        Rd_trv = Rs1_trv;

                        Rs1_trv.setTag(false);
                        Rs1_trv = Rs1_trv;
                    }});
                    0x7: seal ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();
                        if(rs1_cap.type() != CapType::LIN) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }
                        
                        if(!(rs1_cap.hasReadPerm() && rs1_cap.hasWritePerm())) {
                            return std::make_shared<IllegalInstFault>("Insufficient capability permissions (27)", machInst);
                        }

                        uint64_t size = rs1_cap.end() - rs1_cap.start();
                        if(size < sizeof(RegVal) * 33 || !(rs1_cap.start() & (sizeof(RegVal) - 1))) {
                            return std::make_shared<IllegalInstFault>("Illegal operand value (29)", machInst);
                        }

                        rs1_cap.setType(CapType::SEALED);
                        rs1_cap.setAsync(CapAsync::SYNC);
                        Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        Rd_trv = Rs1_trv;

                        Rs1_trv.setTag(false);
                        Rs1_trv = Rs1_trv;
                    }});
                }
                format RNodeOp {
                    0xa: movc ({{
                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        //todo: write cnull to Rs1

                        using namespace gem5::RiscvcapstoneISA::o3;

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        if(RS1 != RD) {
                            Rd_trv = Rs1_trv;

                            Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                            if(Rs1_trv.getTag()) {
                                if(rs1_cap.type() == CapType::NONLIN) {
                                    uint64_t node_id = rs1_cap.nodeId();
                                    dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                                } else {
                                    Rs1_trv.setTag(false);
                                }
                            }
                            Rs1_trv = Rs1_trv;
                        }
                    }});
                    0x6: csplit ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!(Rs1_trv.getTag() && !Rs2_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(!(rs1_cap.type() == CapType::LIN ||
                                rs1_cap.type() == CapType::NONLIN)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        uint64_t start = rs1_cap.start();
                        uint64_t end = rs1_cap.end();
                        uint64_t split_addr = Rs2_trv.getRegVal().intVal();

                        if(!(split_addr > start && split_addr < end)) {
                            return std::make_shared<IllegalInstFault>("Illegal operand value (29)", machInst);
                        }

                        //do I need a query here?
                        NodeID node_id = rs1_cap.nodeId();
                        Fault fault = dyn_inst->initiateNodeCommand(new NodeQuery(node_id));
                        if(fault != NoFault)
                            return fault;

                        auto& node_controller = dyn_inst->getNodeController();
                        NodeID to_allocate = node_controller.tryAllocate();

                        fault = dyn_inst->initiateNodeCommand(new NodeAllocate(node_id, to_allocate, false));
                        if(fault != NoFault)
                            return fault;

                        Rd_trv = Rs1_trv;
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        rd_cap.setBound(split_addr, end);
                        rd_cap.setNodeId(to_allocate);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;

                        rs1_cap.setBound(start, split_addr);
                        Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        Rs1_trv = Rs1_trv;
                    }});
                    0xb: drop ({{
                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Rs1_trv.setTag(false);

                        if(1) { //if Rs1.valid == 1
                            //todo: Rs1.valid = 0
                            using namespace gem5::RiscvcapstoneISA::o3;

                            DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                            assert(dyn_inst);

                            uint64_t node_id = Rs1_trv.getRegVal().capVal().nodeId();
                            dyn_inst->initiateNodeCommand(new NodeDrop(node_id));
                        }

                        Rs1_trv = Rs1_trv;
                    }});
                    0x8: mrev ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }
                        
                        if(Rs1_trv.getRegVal().capVal().type() != CapType::LIN) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        NodeID node_id = Rs1_trv.getRegVal().capVal().nodeId();

                        //do I need this query? if execution has been correct, this node should be
                        //valid right?
                        Fault fault = dyn_inst->initiateNodeCommand(new NodeQuery(node_id));
                        if(fault != NoFault)
                            return fault;

                        auto& node_controller = dyn_inst->getNodeController();
                        NodeID to_allocate = node_controller.tryAllocate();

                        fault = dyn_inst->initiateNodeCommand(new NodeAllocate(node_id, to_allocate));
                        if(fault != NoFault)
                            return fault;

                        Rd_trv = Rs1_trv;
                        Rd_trv.getRegVal().capVal().setNodeId(node_id);
                        Rd_trv.getRegVal().capVal().setType(CapType::REV);

                        Rs1_trv.getRegVal().capVal().setNodeId(to_allocate);

                        Rs1_trv = Rs1_trv;
                    }});
                    0x0: revoke ({{
                        //todo: check linearity field in node to see
                        //if this becomes uninit or lin

                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::REV) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }
                        
                        NodeID node_id = rs1_cap.nodeId();

                        DPRINTFN("Revoke: node_id = %lu\n", node_id);

                        Fault fault = dyn_inst->initiateNodeCommand(new NodeRevoke(node_id));
                        if(fault != NoFault)
                            return fault;

                        uint64_t base = rs1_cap.start();

                        rs1_cap.setType(CapType::UNINIT);
                        rs1_cap.setCursor(base);

                        Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        
                        Rs1_trv = Rs1_trv;
                    }});
                }
                //format CIOp
                format ROp {
                    0x2: tighten ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        DynInst *dyn_inst = dynamic_cast<DynInst *>(xc);
                        assert(dyn_inst);

                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(!(rs1_cap.type() == CapType::LIN || rs1_cap.type() == CapType::NONLIN ||
                                rs1_cap.type() == CapType::UNINIT)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        CapPerm temp = static_cast<CapPerm>(CIIMM5);
                        assert(temp >= CapPerm::NA);

                        if(temp > CapPerm::RWX)
                            temp = CapPerm::NA;

                        if(!decreasing_perms(temp, Rs1_trv.getRegVal().capVal().perm())) {
                            return std::make_shared<IllegalInstFault>(
                                    "Illegal operand value (29)", machInst);
                        }
                        rs1_cap.setPerm(temp);

                        Rd_trv = Rs1_trv;
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;

                        //movc semantics
                        //rs1 still retains the original cap
                        if(rs1_cap.type() != CapType::NONLIN)
                            Rs1_trv.setTag(false);
                        else {
                            uint64_t node_id = rs1_cap.nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }
                        Rs1_trv = Rs1_trv;
                    }});
                }
                format Calls {
                    0x20: call ({{ //execute
                        if(!dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (2)", machInst);
                        }

                        if(!Rs1_trv.getTag())
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::SEALED && rs1_cap.async() != CapAsync::SYNC)
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);

                        //check Rs1 validity
                        dyn_inst->initiateNodeCommand(new NodeQuery(rs1_cap.nodeId()));

                        Addr cur_addr = rs1_cap.start();

                        RegVal dummy;
                        for(int i = 0; i < 3; i++, cur_addr += sizeof(RegVal)) {
                            initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
                            dyn_inst->initiateGetTag(cur_addr);
                        }
                    }}, {{ //comp_code
                        RiscvcapstoneISAInst::PCState pc_state;
                        set(pc_state, xc->pcState());
                        uint64_t npc = pc_state.npc();
                        Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                        pc_cap.setCursor(npc); // prepare the PC cap to save

                        //todo: clear Rs1
                        ra_trv = Rs1_trv;
                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        uint128_t pc_mem_load, ceh_mem_load, csp_mem_load;
                        //need to fix rescheduled call? like a rescheduled load

                        memcpy(&pc_mem_load, dyn_inst->getMemReadRes(0), sizeof(pc_mem_load));
                        memcpy(&ceh_mem_load, dyn_inst->getMemReadRes(1), sizeof(ceh_mem_load));
                        memcpy(&csp_mem_load, dyn_inst->getMemReadRes(2), sizeof(csp_mem_load));
                        //also assert tag results maybe?

                        Addr EA = rs1_cap.start();

                        ConstTaggedRegVal ceh = dyn_inst->readTaggedMiscReg(CAPMISCREG_CEH);
                        Cap ceh_cap = ceh.getRegVal().capVal();

                        Fault fault = writeMemTimingLE(xc, traceData, (uint128_t)pc_cap, EA, Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;
                        fault = writeMemTimingLE(xc, traceData, (uint128_t)ceh_cap, EA + sizeof(RegVal), Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;
                        fault = writeMemTimingLE(xc, traceData, sp_trv.getRegVal().rawCapVal(), EA + 2*sizeof(RegVal), Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;

                        Cap pc_cap_new(pc_mem_load);
                        dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                        NPC = pc_cap_new.cursor();

                        ceh.getRegVal().rawCapVal() = ceh_mem_load;
                        dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, ceh);

                        sp_trv.getRegVal().rawCapVal() = csp_mem_load;
                        sp_trv.setTag(true);
                        sp_trv = sp_trv;

                        rs1_cap.setType(CapType::SEALEDRET);
                        rs1_cap.setCursor(rs1_cap.start());
                        rs1_cap.setReg(RD);
                        rs1_cap.setAsync(CapAsync::SYNC);
                        ra_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                    }});
                }
                format Return {
                    0x21: returni ({{ //execute
                        if(!dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (2)", machInst);
                        }

                        //rs1 != 0 check??
                        if(!Rs1_trv.getTag() || Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::SEALEDRET ||
                            (rs1_cap.type() == CapType::SEALEDRET && rs1_cap.async() == CapAsync::INTERRUPT)) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        dyn_inst->initiateNodeCommand(new NodeQuery(rs1_cap.nodeId()));

                        if(RS1 == 0) {
                            RiscvcapstoneISAInst::PCState pc_state;
                            set(pc_state, xc->pcState());
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(Rs2_trv.getRegVal().intVal());

                            ConstTaggedRegVal v;
                            v.setTag(true);
                            v.getRegVal().rawCapVal() = (uint128_t)pc_cap;

                            dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, v);

                            ConstTaggedRegVal epc = dyn_inst->readTaggedMiscReg(CAPMISCREG_EPC);
                            Cap pc_cap_new = epc.getRegVal().capVal();

                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                            NPC = pc_cap_new.cursor();

                            if(pc_cap_new.type() != CapType::NONLIN) {
                                epc.setTag(false);
                                dyn_inst->setTaggedMiscReg(CAPMISCREG_EPC, epc);
                            } //else rc update
                        } else {
                            if(rs1_cap.async() == CapAsync::SYNC) {
                                Addr cur_addr = rs1_cap.start();

                                RegVal dummy;
                                for(int i = 0; i < 3; i++, cur_addr += sizeof(RegVal)) {
                                    initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
                                    dyn_inst->initiateGetTag(cur_addr);
                                }

                                //set rs1_cap.type() to SEALED and write rs1_cap to rs1_cap.reg()
                            } else { //upon exception
                                Addr cur_addr = rs1_cap.start();

                                RegVal dummy;
                                for(int i = 0; i < 33; i++, cur_addr += sizeof(RegVal)) {
                                    initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
                                    dyn_inst->initiateGetTag(cur_addr);
                                }
                            }
                        }
                    }}, {{ //comp_code
                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.async() == CapAsync::SYNC) {
                            assert(dyn_inst->memReadN == 3);

                            RiscvcapstoneISAInst::PCState pc_state;
                            set(pc_state, xc->pcState());
                            uint64_t npc = pc_state.npc();
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(Rs2_trv.getRegVal().intVal()); // prepare the PC cap to save

                            uint128_t pc_mem_load, ceh_mem_load, csp_mem_load;
                            //need to fix rescheduled call? like a rescheduled load

                            memcpy(&pc_mem_load, dyn_inst->getMemReadRes(0), sizeof(pc_mem_load));
                            memcpy(&ceh_mem_load, dyn_inst->getMemReadRes(1), sizeof(ceh_mem_load));
                            memcpy(&csp_mem_load, dyn_inst->getMemReadRes(2), sizeof(csp_mem_load));
                            //also assert tag results maybe?

                            Addr EA = rs1_cap.start();

                            ConstTaggedRegVal ceh = dyn_inst->readTaggedMiscReg(CAPMISCREG_CEH);
                            Cap ceh_cap = ceh.getRegVal().capVal();

                            Fault fault = writeMemTimingLE(xc, traceData, (uint128_t)pc_cap, EA, Request::Flags(), nullptr);
                                if (fault != NoFault)
                                    return fault;
                            fault = writeMemTimingLE(xc, traceData, (uint128_t)ceh_cap, EA + sizeof(RegVal), Request::Flags(), nullptr);
                                if (fault != NoFault)
                                    return fault;
                            fault = writeMemTimingLE(xc, traceData, sp_trv.getRegVal().rawCapVal(), EA + 2*sizeof(RegVal), Request::Flags(), nullptr);
                                if (fault != NoFault)
                                    return fault;

                            Cap pc_cap_new(pc_mem_load);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                            NPC = pc_cap_new.cursor();

                            ceh.getRegVal().rawCapVal() = ceh_mem_load;
                            dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, ceh);

                            sp_trv.getRegVal().rawCapVal() = csp_mem_load;
                            sp_trv.setTag(true);
                            sp_trv = sp_trv;

                            RegId cap_reg(IntRegClass, rs1_cap.reg());
                            rs1_cap.setType(CapType::SEALED);
                            Rs1_trv.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                            //might not work
                            //todo: need to set tag true
                            dyn_inst->cpu->setArchReg(cap_reg, Rs1_trv.getRegVal(), dyn_inst->threadNumber);
                        } else if(rs1_cap.async() == CapAsync::EXCEPT) {
                            assert(dyn_inst->memReadN == 33);

                            RiscvcapstoneISAInst::PCState pc_state;
                            set(pc_state, xc->pcState());
                            uint64_t npc = pc_state.npc();
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(Rs2_trv.getRegVal().intVal()); // prepare the PC cap to save

                            uint128_t pc_mem_load;
                            //need to fix rescheduled call? like a rescheduled load

                            memcpy(&pc_mem_load, dyn_inst->getMemReadRes(0), sizeof(pc_mem_load));
                            //also assert tag results maybe?

                            Addr cur_addr = rs1_cap.start() + 2 * sizeof(RegVal);

                            ConstTaggedRegVal ceh = dyn_inst->readTaggedMiscReg(CAPMISCREG_CEH);
                            Cap ceh_cap = ceh.getRegVal().capVal();

                            Fault fault = writeMemTimingLE(xc, traceData, (uint128_t)pc_cap, cur_addr, Request::Flags(), nullptr);
                                if (fault != NoFault)
                                    return fault;
                            fault = writeMemTimingLE(xc, traceData, (uint128_t)ceh_cap, cur_addr + sizeof(RegVal), Request::Flags(), nullptr);
                                if (fault != NoFault)
                                    return fault;

                            rs1_cap.setType(CapType::SEALED);
                            rs1_cap.setAsync(CapAsync::SYNC);

                            ceh.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                            dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, ceh);

                            Cap pc_cap_new(pc_mem_load);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                            NPC = pc_cap_new.cursor();

                            //write context
                            for(int i = 0; i < NumIntArchRegs; i ++, cur_addr += sizeof(RegVal)) {
                                ConstTaggedRegVal v;
                                v = dyn_inst->getTaggedRegOperand(this, i);

                                // store value
                                // DPRINTFN("Write context x%d %llx\n", i, v.getRegVal().intVal());
                                fault = writeMemTimingLE(xc, traceData, v.getRegVal(), cur_addr, 
                                Request::Flags(), nullptr);
                                if(fault != NoFault) {
                                    return fault;
                                }
                                // store tag
                                //DPRINTFN("Set tag %d %d\n", i, v.getTag());
                                fault = dyn_inst->initiateSetTag(cur_addr, v.getTag());
                                if(fault != NoFault) {
                                    return fault;
                                }
                            }

                            for(int reg_idx = 0; reg_idx < NumIntArchRegs; reg_idx ++) {
                                RegVal& v = *(RegVal*)(dyn_inst->getMemReadRes(reg_idx + 2));
                                ConstTagRef tag = dyn_inst->getTagQueryRes(reg_idx + 2);
                                //DPRINTFN("Load context reg %d  = 0x%llx (tag = %d)\n",
                                //    reg_idx, v.intVal(), tag);
            
                                // write back to registers
                                ConstTaggedRegVal tagged_val(v, tag);
                                dyn_inst->setTaggedRegOperand(this, reg_idx, tagged_val);
                            }
                        }

                        Rs1_trv.setTag(false);
                        Rs1_trv = Rs1_trv;
                    }});
                }
                format CapEnter {
                    0x42: capenter ({{
                        if(dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (0)", machInst);
                        }

                        if(!(Rs1_trv.getTag())) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::SEALED) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        NodeID node_id = rs1_cap.nodeId();
                        dyn_inst->initiateNodeCommand(new NodeQuery(node_id));

                        if(rs1_cap.async() == CapAsync::SYNC) {
                            Addr cur_addr = rs1_cap.start();

                            RegVal dummy;
                            for(int i = 0; i < 3; i++, cur_addr += sizeof(RegVal)) {
                                initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
                                dyn_inst->initiateGetTag(cur_addr);
                            }
                        } else { //upon exception or interrupt
                            Addr cur_addr = rs1_cap.start();

                            RegVal dummy;
                            for(int i = 0; i < 33; i++, cur_addr += sizeof(RegVal)) {
                                initiateMemRead(xc, traceData, cur_addr, dummy, Request::Flags());
                                dyn_inst->initiateGetTag(cur_addr);
                            }
                        }
                    }}, {{
                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();
                        CPU *cpu = dynamic_cast<CPU *>(dyn_inst->cpu);

                        if(rs1_cap.async() == CapAsync::SYNC) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            uint64_t pc = pc_cap.cursor();

                            cpu->normal_pc[dyn_inst->threadNumber] = PC;
                            cpu->normal_sp[dyn_inst->threadNumber] = sp_trv;

                            uint128_t pc_mem_load, ceh_mem_load, csp_mem_load;
                            //need to fix rescheduled call? like a rescheduled load
                            //it's serializing, why would it be rescheduled

                            memcpy(&pc_mem_load, dyn_inst->getMemReadRes(0), sizeof(pc_mem_load));
                            memcpy(&ceh_mem_load, dyn_inst->getMemReadRes(1), sizeof(ceh_mem_load));
                            memcpy(&csp_mem_load, dyn_inst->getMemReadRes(2), sizeof(csp_mem_load));
                            //also assert tag results maybe?

                            Cap pc_cap_new(pc_mem_load);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                            NPC = pc_cap_new.cursor();

                            ConstTaggedRegVal ceh;
                            ceh.setTag(true);
                            ceh.getRegVal().rawCapVal() = ceh_mem_load;
                            dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, ceh);

                            sp_trv.getRegVal().rawCapVal() = csp_mem_load;
                            sp_trv.setTag(true);
                            sp_trv = sp_trv;

                            ConstTaggedRegVal temp_cra;
                            temp_cra.setTag(true);
                            rs1_cap.setType(CapType::EXIT);
                            rs1_cap.setCursor(rs1_cap.start());
                            temp_cra.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                            ra_trv = temp_cra;

                            cpu->switch_reg[dyn_inst->threadNumber] = RS1;
                            cpu->exit_reg[dyn_inst->threadNumber] = RD;
                        } else {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            uint64_t pc = pc_cap.cursor();

                            cpu->normal_pc[dyn_inst->threadNumber] = PC;
                            cpu->normal_sp[dyn_inst->threadNumber] = sp_trv;

                            uint128_t pc_mem_load, ceh_mem_load;
                            //need to fix rescheduled call? like a rescheduled load
                            //it's serializing, why would it be rescheduled

                            memcpy(&pc_mem_load, dyn_inst->getMemReadRes(0), sizeof(pc_mem_load));
                            memcpy(&ceh_mem_load, dyn_inst->getMemReadRes(1), sizeof(ceh_mem_load));
                            //also assert tag results maybe?

                            Cap pc_cap_new(pc_mem_load);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap_new, dyn_inst->threadNumber);

                            NPC = pc_cap_new.cursor();

                            ConstTaggedRegVal ceh;
                            ceh.setTag(true);
                            ceh.getRegVal().rawCapVal() = ceh_mem_load;
                            dyn_inst->setTaggedMiscReg(CAPMISCREG_CEH, ceh);

                            for(int reg_idx = 0; reg_idx < NumIntArchRegs; reg_idx ++) {
                                RegVal& v = *(RegVal*)(dyn_inst->getMemReadRes(reg_idx + 2));
                                ConstTagRef tag = dyn_inst->getTagQueryRes(reg_idx + 2);
                                //DPRINTFN("Load context reg %d  = 0x%llx (tag = %d)\n",
                                //    reg_idx, v.intVal(), tag);
            
                                // write back to registers
                                ConstTaggedRegVal tagged_val(v, tag);
                                dyn_inst->setTaggedRegOperand(this, reg_idx, tagged_val);
                            }

                            rs1_cap.setType(CapType::UNINIT);
                            rs1_cap.setCursor(rs1_cap.start());

                            ConstTaggedRegVal temp_switch_cap;
                            temp_switch_cap.setTag(true);
                            temp_switch_cap.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                            dyn_inst->setTaggedMiscReg(CAPMISCREG_SWITCH_CAP, temp_switch_cap);

                            cpu->switch_reg[dyn_inst->threadNumber] = RS1;
                            cpu->exit_reg[dyn_inst->threadNumber] = RD;
                        }

                        cpu->cwrld[dyn_inst->threadNumber] = 1;
                    }});
                }
                format CapExit {
                    0x43: capexit ({{
                        //i don't need comp code do i?
                        CPU *cpu = dynamic_cast<CPU *>(dyn_inst->cpu);

                        if(!dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (2)", machInst);
                        }

                        if(!Rs1_trv.getTag() || Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                        if(rs1_cap.type() != CapType::EXIT) {
                            return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                        }

                        NodeID node_id = rs1_cap.nodeId();
                        dyn_inst->initiateNodeCommand(new NodeQuery(node_id));

                        Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                        pc_cap.setCursor(Rs2_trv.getRegVal().intVal()); // prepare the PC cap to save

                        ConstTaggedRegVal ceh = dyn_inst->readTaggedMiscReg(CAPMISCREG_CEH);
                        Cap ceh_cap = ceh.getRegVal().capVal();

                        Addr EA = rs1_cap.start();

                        //todo: load the cap from the mem location and update refcount
                        //also, update refcount for pc, ceh and csp
                        Fault fault = writeMemTimingLE(xc, traceData, (uint128_t)pc_cap, EA, Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;
                        fault = writeMemTimingLE(xc, traceData, (uint128_t)ceh_cap, EA + sizeof(RegVal), Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;
                        fault = writeMemTimingLE(xc, traceData, sp_trv.getRegVal().rawCapVal(), EA + 2*sizeof(RegVal), Request::Flags(), nullptr);
                            if (fault != NoFault)
                                return fault;

                        sp_trv = cpu->normal_sp[dyn_inst->threadNumber];
                        NPC = cpu->normal_pc[dyn_inst->threadNumber] + 4;

                        rs1_cap.setType(CapType::SEALED);
                        rs1_cap.setAsync(CapAsync::SYNC);
                        unsigned reg_idx = cpu->switch_reg[dyn_inst->threadNumber];
                        ConstTaggedRegVal tagged_val;
                        tagged_val.setTag(true);
                        tagged_val.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                        dyn_inst->setTaggedRegOperand(this, reg_idx, tagged_val);

                        //use a different variable here or this is okay?
                        tagged_val.setTag(false);
                        tagged_val.getRegVal().intVal() = 0;
                        reg_idx = cpu->exit_reg[dyn_inst->threadNumber];
                        dyn_inst->setTaggedRegOperand(this, reg_idx, tagged_val);

                        cpu->cwrld[dyn_inst->threadNumber] = 0;
                    }});
                }
            }
            format IOp {
                0x2: cincoffsetimm ({{
                    using namespace gem5::RiscvcapstoneISA::o3;
                    DynInst *dyn_inst = dynamic_cast<DynInst *>(xc);
                    assert(dyn_inst);

                    //todo: set Rs1 to cnull
                    if(!(Rs1_trv.getTag())) {
                        return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                    }

                    Cap rs1_cap = Rs1_trv.getRegVal().capVal();

                    if(rs1_cap.type() == CapType::UNINIT ||
                            rs1_cap.type() == CapType::SEALED) {
                        return std::make_shared<IllegalInstFault>("Unexpected capability type (26)", machInst);
                    }

                    int64_t imm = sext<12>(IMM12);

                    rs1_cap.setCursor(rs1_cap.cursor() + imm);

                    ConstTaggedRegVal temp;
                    temp.getRegVal().rawCapVal() = (uint128_t)rs1_cap;
                    temp.setTag(true);

                    Rd_trv = temp;

                    //movc semantics
                    //rs1 still retains the original cap
                    if(rs1_cap.type() != CapType::NONLIN)
                        Rs1_trv.setTag(false);
                    else {
                        uint64_t node_id = rs1_cap.nodeId();
                        dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                    }
                    Rs1_trv = Rs1_trv;
                }});
            }
            format RNodeMemOp {
                0x3: ldc ({{ //ea_code
                        Fault fault = dyn_inst->initiateGetTag(EA);
                        if(fault != NoFault)
                            return fault;
                    }}, {{ //comp_code
                        bool tag_res = dyn_inst->getTagQueryRes(0);
                        if(!tag_res) {
                            return std::make_shared<IllegalInstFault>(
                                    "Load access fault (5)", machInst);
                        }

                        Addr EA;
                        int64_t imm = sext<12>(IMM12);

                        if(Rs1_trv.getTag()) {
                            EA = Rs1_trv.getRegVal().capVal().cursor() + imm;
                        } else {
                            EA = Rs1_trv.getRegVal().intVal() + imm;
                        }

                        ConstTaggedRegVal temp_regval;
                        uint128_t& cap = Mem_rv.rawCapVal();

                        getMemLE(pkt, cap, traceData);

                        temp_regval.getRegVal() = Mem_rv;
                        temp_regval.setTag(true);

                        using namespace gem5::RiscvcapstoneISA::o3;

                        if(Mem_rv.capVal().type() != CapType::NONLIN) {
                            dyn_inst->initiateSetTag(EA, false);
                        } else {
                            NodeID node_id = Mem_rv.capVal().nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }

                        Rd_trv = temp_regval;
                    }});
            }
            //format IOp {
            format ROp {
                0x5: cjalr ({{
                        //replacing the capability inside IEW,
                        //which holds the permissions and bounds,
                        //AND the NPC which holds the cursor

                        using namespace gem5::RiscvcapstoneISA::o3;

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        if(!dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (2)", machInst);
                        }

                        if(!Rs1_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                        }

                        Cap rs1_cap = Rs1_trv.getRegVal().capVal();
                        int64_t imm = sext<12>(IMM12);
                        NPC = rs1_cap.cursor() + imm;

                        //write pc to rd
                        //todo: actually pc + 4
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);

                        dyn_inst->cpu->getIEWObject().setPCCap(rs1_cap,
                                                            dyn_inst->threadNumber);

                        //write cnull to rs1
                        if(RS1 != RD) {
                            if(rs1_cap.type() != CapType::NONLIN) {
                                Rs1_trv.setTag(false);
                            } else {
                                NodeID node_id = Rs1_trv.getRegVal().capVal().nodeId();
                                dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                            }
                        }

                        Rs1_trv = Rs1_trv;
                        Rd_trv = Rd_trv;
                }}, IsUncondControl);
                0x6: cbnz ({{
                    using namespace gem5::RiscvcapstoneISA::o3;

                    DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                    assert(dyn_inst);

                    if(!dyn_inst->isSecureWorld()) {
                            return std::make_shared<IllegalInstFault>("Illegal instruction (2)", machInst);
                    }

                    if(!(Rd_trv.getTag() && !Rs1_trv.getTag())) {
                        return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);
                    }

                    //should I set PC or NPC hmmm
                    if(Rs1_trv.getRegVal().intVal() != 0) {
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        int64_t imm = sext<12>(IMM12);
                        rd_cap.setCursor(rd_cap.cursor() + imm);

                        dyn_inst->cpu->getIEWObject().setPCCap(rd_cap, dyn_inst->threadNumber);

                        NPC = rd_cap.cursor();

                        //write cnull to rd
                        if(rd_cap.type() != CapType::NONLIN) {
                            Rd_trv.setTag(false);
                        } else {
                            NodeID node_id = rd_cap.nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }
                    }

                    Rd_trv = Rd_trv;
                }}, IsCondControl);
            }
            format RNodeStoreMemOp {
                0x4: stc ({{ //check_code
                        if(!Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>(
                                "Unexpected operand type (24)", machInst);
                        }
                    }}, {{ //memacc_code
                        Mem_rv = Rs2_trv.getRegVal();

                        Fault fault = writeMemTimingLE(xc, traceData, Mem.rawCapVal(), EA,
                                        memAccessFlags, nullptr);
                        if (fault != NoFault)
                            return fault;
                    }}, {{ //comp_code
                        //todo: optimization: update loaded cap refcount only if nodeid != Rs2.nodeid

                        if(Rs2_trv.getRegVal().capVal().type() != CapType::NONLIN)
                            Rs2_trv.setTag(false);
                        else {
                            NodeID node_id = Rs2_trv.getRegVal().capVal().nodeId();
                            dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                        }

                        Rs2_trv = Rs2_trv;
                        Rs1_trv = Rs1_trv;
                    }}, IsStore);
            }
            format CCSROp {
                0x7: ccsrrw ({{
                    using namespace gem5::RiscvcapstoneISA::o3;
                    DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                    assert(dyn_inst);

                    if(!Rs1_trv.getTag())
                        return std::make_shared<IllegalInstFault>("Unexpected operand type (24)", machInst);

                    switch(FUNCT12) {
                        case CCSR_CEH: case CCSR_EPC:
                        {
                            ConstTaggedRegVal reg_val = dyn_inst->readTaggedMiscReg(FUNCT12);
                            Rd_trv = reg_val;
                            dyn_inst->setTaggedMiscReg(FUNCT12, Rs1_trv);
                            if(Rs1_trv.getRegVal().capVal().type() != CapType::NONLIN)
                                Rs1_trv.setTag(false);
                            else {
                                NodeID node_id = Rs1_trv.getRegVal().capVal().nodeId();
                                dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, 1));
                            }
                            Rs1_trv = Rs1_trv;
                            break;
                        }
                        case CCSR_CINIT:
                        {
                            ConstTaggedRegVal reg_val = dyn_inst->readTaggedMiscReg(FUNCT12);
                            if(!reg_val.getTag());
                            else {
                                Rd_trv = reg_val;
                                reg_val.setTag(false);
                                dyn_inst->setTaggedMiscReg(FUNCT12, reg_val);
                            }
                            break;
                        }
                        default:
                            return std::make_shared<IllegalInstFault>("Illegal operand value (29)", machInst);
                    }

                    return NoFault;
                }}, IsNonSpeculative, IsSerializeAfter);
            }
            //Capstone Test Ops
            0x0: decode FUNCT7 {
                format QueryTest {
                    0x0: query ({{
                        Rs1; Rs2; Rd;
                    }});
                }
                format DropTest {
                    0x1: dropt ({{
                        Rs1; Rs2; Rd;
                    }});
                }
                format RcUpdateTest {
                    0x2: rcup ({{
                        Rs1; Rs2; Rd;
                    }});
                }
                format AllocTest {
                    0x3: alloc ({{
                        Rs1; Rs2; Rd;
                    }});
                }
                format RevokeTest {
                    0x4: revoket ({{
                        Rs1; Rs2; Rd;
                    }});
                }
                format ROp {
                    0x5: capcreate ({{
                        Rd_trv.setTag(true);
                        Rd_trv = Rd_trv; // just to make the dumb parser happy
                    }});
                    0x6: captype ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        assert(Rd_trv.getTag());
                        //using CapType = gem5::RiscvcapstoneISA::o3::CapType;
                        CapType temp = static_cast<CapType>(Rs1);
                        assert(temp >= CapType::LIN && temp <= CapType::EXIT);
                        //Rd_trv.getRegVal().val.cap.setType(temp);
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        rd_cap.setType(temp);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv; // just to make the dumb parser happy
                    }});
                    0x7: capnode ({{
                        assert(Rd_trv.getTag());
                        using namespace gem5::RiscvcapstoneISA::o3;
                        //Rd_trv.getRegVal().val.cap.setNodeId(static_cast<NodeID>(Rs1));
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        rd_cap.setNodeId(Rs1);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv; // just to make the dumb parser happy
                    }});
                    0x8: capperm ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        assert(Rd_trv.getTag());
                        //using CapPerm = gem5::RiscvcapstoneISA::o3::CapPerm;
                        CapPerm temp = static_cast<CapPerm>(Rs1);
                        assert(temp >= CapPerm::NA && temp <= CapPerm::RWX);
                        //Rd_trv.getRegVal().val.cap.setPerm(temp);
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        rd_cap.setPerm(temp);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv; // just to make the dumb parser happy
                    }});
                    0x9: capbound ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        assert(Rd_trv.getTag());
                        //DPRINTFN("Set capability bound to (%llx, %llx)\n", Rs1, Rs2);
                        //Rd_trv.getRegVal().val.cap.setAddresses(Rs1, Rs2, Rs1);
                        Cap rd_cap = Rd_trv.getRegVal().capVal();
                        rd_cap.setAddresses(Rs1, Rs2, Rs1);
                        Rd_trv.getRegVal().rawCapVal() = (uint128_t)rd_cap;
                        Rd_trv = Rd_trv; // just to make the dumb parser happy
                    }});
                    0xa: capprint ({{
                        //const RegVal& reg_val = Rs1_trv.getRegVal();
                        gem5::RiscvcapstoneISA::o3::Cap rs1_cap = Rs1_trv.getRegVal().capVal();
                        DPRINTFN("Capability (tag = %u) = (%llx, %llx), %llx, perm = %u, type = %u, node = %llu\n",
                                Rs1_trv.getTag(),
                                rs1_cap.start(), rs1_cap.end(),
                                rs1_cap.cursor(),
                                static_cast<unsigned int>(rs1_cap.perm()),
                                static_cast<unsigned int>(rs1_cap.type()),
                                rs1_cap.nodeId());
                    }}, IsSerializing, IsNonSpeculative, IsSerializeAfter);
                    0xd: printregs ({{
                        using namespace gem5::RiscvcapstoneISA::o3;
                        DynInst *dyn_inst = dynamic_cast<DynInst *>(xc);
                        assert(dyn_inst);
                        dyn_inst->printRegs();
                    }}, IsSerializing, IsNonSpeculative, IsSerializeAfter);
                    0xe: getrand ({{
                        srand(time(NULL));
                        Rd = (rand() % (Rs2 - Rs1) + Rs1) & 0xFFFFFFFFFFFFFFF0;
                    }});
                }
                format TagAccessStore {
                    0xb: tagset ({{
                        EA = Rs1_ud;

                        dyn_inst->initiateSetTag(EA, Rs2_ud ? true : false);
                    }});
                }
                format TagAccess {
                    0xc: tagget ({{
                        EA = Rs1_ud;
                        uint64_t _dd = Rs2;

                        dyn_inst->initiateGetTag(EA);
                    }}, {{
                        DPRINTFN("tag = %u\n",
                                    dyn_inst->getTagQueryRes(0));
                    }});
                }
                format RNodeOp {
                    0xf: printnode ({{
                        using namespace gem5::RiscvcapstoneISA::o3;

                        DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                        assert(dyn_inst);

                        NodeID node_id = Rs1_ud;
                        dyn_inst->initiateNodeCommand(new NodeQueryDbg(node_id));
                    }}, IsSerializing, IsNonSpeculative);
                }
            }
            //End Capstone Test Ops
        }
        //End Capstone Ops
        0x00: decode FUNCT3 {
            format RNodeMemOp {
                0x0: lb ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_sb, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_sb;
                    }});
                0x1: lh ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_sh, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_sh;
                    }});
                0x2: lw ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_sw, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_sw;
                    }});
                0x3: ld ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_sd, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_sd;
                    }});
                0x4: lbu ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_ub, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_ub;
                    }});
                0x5: lhu ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_uh, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_uh;
                    }});
                0x6: lwu ({{ //ea_code
                        
                    }}, {{ //comp_code
                        Rs1_trv;
                        getMemLE(pkt, Mem_uw, traceData);

                        Rd_trv.getRegVal().intVal() = Mem_uw;
                    }});
            }
        }

        0x01: decode FUNCT3 {
            format Load {
                0x1: flh({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);
                    freg_t fd;
                    fd = freg(f16(Mem_uh));
                    Fd_bits = fd.v;
                }}, inst_flags=FloatMemReadOp);
                0x2: flw({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);
                    freg_t fd;
                    fd = freg(f32(Mem_uw));
                    Fd_bits = fd.v;
                }}, inst_flags=FloatMemReadOp);
                0x3: fld({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);
                    freg_t fd;
                    fd = freg(f64(Mem));
                    Fd_bits = fd.v;
                }}, inst_flags=FloatMemReadOp);
            }
        }

        0x03: decode FUNCT3 {
            format FenceOp {
                0x0: fence({{
                }}, uint64_t, IsReadBarrier, IsWriteBarrier, No_OpClass);
                0x1: fence_i({{
                }}, uint64_t, IsNonSpeculative, IsSerializeAfter, No_OpClass);
            }
        }

        0x04: decode FUNCT3 {
            0x1: decode FS3 {
                format IOp {
                    0x00: slli({{
                        if(Rs1_trv.getTag()) {
                        return std::make_shared<IllegalInstFault>(
                            "slli: Can't perform this op on a capability!", machInst);
                        }

                        Rd_trv.getRegVal().intVal() = Rs1_trv.getRegVal().intVal() << imm;

                        Rd_trv = Rd_trv;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x05: bseti({{
                        uint64_t index = imm & (64 - 1);
                        Rd = Rs1 | (UINT64_C(1) << index);
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x09: bclri({{
                        uint64_t index = imm & (64 - 1);
                        Rd = Rs1 & (~(UINT64_C(1) << index));
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x0d: binvi({{
                        uint64_t index = imm & (64 - 1);
                        Rd = Rs1 ^ (UINT64_C(1) << index);
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                }
                format ROp {
                    0x0c: decode RS2 {
                        0x00: clz({{
                            Rd = clz64(Rs1);
                        }});
                        0x01: ctz({{
                            Rd = ctz64(Rs1);
                        }});
                        0x02: cpop({{
                            Rd = popCount(Rs1);
                        }});
                        0x04: sextb({{
                            Rd = sext<8>(Rs1_ub);
                        }});
                        0x05: sexth({{
                            Rd = sext<16>(Rs1_uh);
                        }});
                    }
                }
            }

            format IOp {
                0x0: addi({{
                    if(Rs1_trv.getTag()) {
                        return std::make_shared<IllegalInstFault>(
                            "addi: Can't perform this op on a capability!", machInst);
                    }
                    Rd_trv.getRegVal().intVal() = Rs1_trv.getRegVal().intVal() + imm;

                    Rd_trv = Rd_trv;
                }});
                0x2: slti({{
                    Rd = (Rs1_sd < imm) ? 1 : 0;
                }});
                0x3: sltiu({{
                    Rd = (Rs1 < imm) ? 1 : 0;
                }}, uint64_t);
                0x4: xori({{
                    Rd = Rs1 ^ imm;
                }}, uint64_t);
                0x5: decode FS3 {
                    0x0: srli({{
                        Rd = Rs1 >> imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x5: orcb({{
                        Rd = 0;
                        Rd |= (Rs1<7:0> ? UINT64_C(0xff) : 0x0);
                        Rd |= (Rs1<15:8> ? UINT64_C(0xff) : 0x0) << 8;
                        Rd |= (Rs1<23:16> ? UINT64_C(0xff) : 0x0) << 16;
                        Rd |= (Rs1<31:24> ? UINT64_C(0xff) : 0x0) << 24;
                        Rd |= (Rs1<39:32> ? UINT64_C(0xff) : 0x0) << 32;
                        Rd |= (Rs1<47:40> ? UINT64_C(0xff) : 0x0) << 40;
                        Rd |= (Rs1<55:48> ? UINT64_C(0xff) : 0x0) << 48;
                        Rd |= (Rs1<63:56> ? UINT64_C(0xff) : 0x0) << 56;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x8: srai({{
                        Rd_sd = Rs1_sd >> imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x9: bexti({{
                        uint64_t index = imm & (64 - 1);
                        Rd = (Rs1 >> index) & 0x1;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0xc: rori({{
                        Rd = (Rs1 >> imm) | (Rs1 << ((64 - imm) & (64 - 1)));
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0xd: decode RS2 {
                        0x18: rev8({{
                            Rd = 0;
                            Rd |= ((Rs1 & 0xffULL) << 56) | (((Rs1 >> 56) & 0xffULL));
                            Rd |= (((Rs1 >> 8) & 0xffULL) << 48) | (((Rs1 >> 48) & 0xffULL) << 8);
                            Rd |= (((Rs1 >> 16) & 0xffULL) << 40) | (((Rs1 >> 40) & 0xffULL) << 16);
                            Rd |= (((Rs1 >> 24) & 0xffULL) << 32) | (((Rs1 >> 32) & 0xffULL) << 24);
                        }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    }
                }
                0x6: ori({{
                    Rd = Rs1 | imm;
                }}, uint64_t);
                0x7: andi({{
                    Rd = Rs1 & imm;
                }}, uint64_t);
            }
        }

        0x05: UOp::auipc({{
            Rd = PC + (sext<20>(imm) << 12);
        }});

        0x06: decode FUNCT3 {
            format IOp {
                0x0: addiw({{
                    if(Rs1_trv.getTag()) {
                        return std::make_shared<IllegalInstFault>(
                            "addiw: Can't perform this op on a capability!", machInst);
                    }
                    Rs1_trv.getRegVal().intVal() = (int32_t)(Rs1_trv.getRegVal().intVal() + imm);

                    Rs1_trv = Rs1_trv;
                }}, int32_t);
                0x1: decode FS3 {
                    0x0: slliw({{
                        Rd_sd = Rs1_sw << imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT5; }});
                    0x1: slliuw({{
                        Rd = ((uint64_t)(Rs1_uw)) << imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT5; }});
                    0xc: decode FS2 {
                        0x0: clzw({{
                            Rd = clz32(Rs1);
                        }});
                        0x1: ctzw({{
                            Rd = ctz32(Rs1);
                        }});
                        0x2: cpopw({{
                            Rd = popCount(Rs1<31:0>);
                        }});
                    }
                }
                0x5: decode FS3 {
                    0x0: srliw({{
                        Rd_sd = (int32_t)(Rs1_uw >> imm);
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT5; }});
                    0x8: sraiw({{
                        Rd_sd = Rs1_sw >> imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT5; }});
                    0xc: roriw({{
                        Rd = (int32_t) ((Rs1_uw >> imm) | (Rs1_uw << ((32 - imm) & (32 - 1))));
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT5; }});
                }
            }
        }

        0x08: decode FUNCT3 {
            format RNodeStoreMemOp {
                0x0: sb ({{ //check_code
                        if(Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>(
                                    "Unexpected operand type (24)", machInst);
                        }
                    }}, {{ //memacc_code
                        Mem_sb = Rs2_trv.getRegVal().intVal();

                        Fault fault = writeMemTimingLE(xc, traceData, Mem_sb, EA,
                                          memAccessFlags, nullptr);
                            if (fault != NoFault)
                                return fault;
                    }}, {{ // comp_code
                        Rs1_trv = Rs1_trv;
                    }}, IsStore);
                0x1: sh ({{ //check_code
                        if(Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>(
                                    "Unexpected operand type (24)", machInst);
                        }
                    }}, {{ //memacc_code
                        Mem_sh = Rs2_trv.getRegVal().intVal();

                        Fault fault = writeMemTimingLE(xc, traceData, Mem_sh, EA,
                                          memAccessFlags, nullptr);
                            if (fault != NoFault)
                                return fault;
                    }}, {{ // comp_code
                        Rs1_trv = Rs1_trv;
                    }}, IsStore);
                0x2: sw ({{ //check_code
                        if(Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>(
                                    "Unexpected operand type (24)", machInst);
                        }
                    }}, {{ //memacc_code
                        Mem_sw = Rs2_trv.getRegVal().intVal();

                        Fault fault = writeMemTimingLE(xc, traceData, Mem_sw, EA,
                                          memAccessFlags, nullptr);
                            if (fault != NoFault)
                                return fault;
                    }}, {{ // comp_code
                        Rs1_trv = Rs1_trv;
                    }}, IsStore);
                0x3: sd ({{ //check_code
                        if(Rs2_trv.getTag()) {
                            return std::make_shared<IllegalInstFault>(
                                    "Unexpected operand type (24)", machInst);
                        }
                    }}, {{ //memacc_code
                        Mem_sd = Rs2_trv.getRegVal().intVal();

                        Fault fault = writeMemTimingLE(xc, traceData, Mem_sd, EA,
                                          memAccessFlags, nullptr);
                            if (fault != NoFault)
                                return fault;
                    }}, {{ // comp_code
                        Rs1_trv = Rs1_trv;
                    }}, IsStore);
            }
        }

        0x09: decode FUNCT3 {
            format Store {
                0x1: fsh({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem_uh = (uint16_t)Fs2_bits;
                }}, inst_flags=FloatMemWriteOp);
                0x2: fsw({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem_uw = (uint32_t)Fs2_bits;
                }}, inst_flags=FloatMemWriteOp);
                0x3: fsd({{
                    STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem_ud = Fs2_bits;
                }}, inst_flags=FloatMemWriteOp);
            }
        }

        0x0b: decode FUNCT3 {
            0x2: decode AMOFUNCT {
                0x2: LoadReserved::lr_w({{
                    Rd_sd = Mem_sw;
                }}, mem_flags=LLSC);
                0x3: StoreCond::sc_w({{
                    Mem_uw = Rs2_uw;
                }}, {{
                    Rd = result;
                }}, inst_flags=IsStoreConditional, mem_flags=LLSC);
                0x0: AtomicMemOp::amoadd_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                          new AtomicGenericOp<int32_t>(Rs2_sw,
                                  [](int32_t* b, int32_t a){ *b += a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x1: AtomicMemOp::amoswap_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2_uw,
                                  [](uint32_t* b, uint32_t a){ *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x4: AtomicMemOp::amoxor_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2_uw,
                                  [](uint32_t* b, uint32_t a){ *b ^= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x8: AtomicMemOp::amoor_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2_uw,
                                  [](uint32_t* b, uint32_t a){ *b |= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0xc: AtomicMemOp::amoand_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2_uw,
                                  [](uint32_t* b, uint32_t a){ *b &= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x10: AtomicMemOp::amomin_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2_sw,
                        [](int32_t* b, int32_t a){ if (a < *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x14: AtomicMemOp::amomax_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2_sw,
                        [](int32_t* b, int32_t a){ if (a > *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x18: AtomicMemOp::amominu_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2_uw,
                        [](uint32_t* b, uint32_t a){ if (a < *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x1c: AtomicMemOp::amomaxu_w({{
                    Rd_sd = Mem_sw;
                }}, {{
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2_uw,
                        [](uint32_t* b, uint32_t a){ if (a > *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
            }
            0x3: decode AMOFUNCT {
                0x2: LoadReserved::lr_d({{
                    Rd_sd = Mem_sd;
                }}, mem_flags=LLSC);
                0x3: StoreCond::sc_d({{
                    Mem = Rs2;
                }}, {{
                    Rd = result;
                }}, mem_flags=LLSC, inst_flags=IsStoreConditional);
                0x0: AtomicMemOp::amoadd_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<int64_t> *amo_op =
                          new AtomicGenericOp<int64_t>(Rs2_sd,
                                  [](int64_t* b, int64_t a){ *b += a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x1: AtomicMemOp::amoswap_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2_ud,
                                  [](uint64_t* b, uint64_t a){ *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x4: AtomicMemOp::amoxor_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2_ud,
                                 [](uint64_t* b, uint64_t a){ *b ^= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x8: AtomicMemOp::amoor_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2_ud,
                                 [](uint64_t* b, uint64_t a){ *b |= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0xc: AtomicMemOp::amoand_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2_ud,
                                 [](uint64_t* b, uint64_t a){ *b &= a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x10: AtomicMemOp::amomin_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<int64_t> *amo_op =
                      new AtomicGenericOp<int64_t>(Rs2_sd,
                        [](int64_t* b, int64_t a){ if (a < *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x14: AtomicMemOp::amomax_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<int64_t> *amo_op =
                      new AtomicGenericOp<int64_t>(Rs2_sd,
                        [](int64_t* b, int64_t a){ if (a > *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x18: AtomicMemOp::amominu_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                      new AtomicGenericOp<uint64_t>(Rs2_ud,
                        [](uint64_t* b, uint64_t a){ if (a < *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
                0x1c: AtomicMemOp::amomaxu_d({{
                    Rd_sd = Mem_sd;
                }}, {{
                    TypedAtomicOpFunctor<uint64_t> *amo_op =
                      new AtomicGenericOp<uint64_t>(Rs2_ud,
                        [](uint64_t* b, uint64_t a){ if (a > *b) *b = a; });
                }}, mem_flags=ATOMIC_RETURN_OP);
            }
        }
        0x0c: decode FUNCT3 {
            format ROp {
                0x0: decode FUNCT7 {
                    0x0: add({{
                        Rd = Rs1_sd + Rs2_sd;
                    }});
                    0x1: mul({{
                        Rd = Rs1_sd*Rs2_sd;
                    }}, IntMultOp);
                    0x20: sub({{
                        Rd = Rs1_sd - Rs2_sd;
                    }});
                }
                0x1: decode FUNCT7 {
                    0x0: sll({{
                        Rd = Rs1 << Rs2<5:0>;
                    }});
                    0x1: mulh({{
                        bool negate = (Rs1_sd < 0) != (Rs2_sd < 0);

                        uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                        uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                        uint64_t Rs2_lo = (uint32_t)std::abs(Rs2_sd);
                        uint64_t Rs2_hi = (uint64_t)std::abs(Rs2_sd) >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs2_lo*Rs1_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        uint64_t res = hi +
                                       (mid1 >> 32) +
                                       (mid2 >> 32) +
                                       carry;
                        Rd = negate ? ~res + (Rs1_sd*Rs2_sd == 0 ? 1 : 0)
                                    : res;
                    }}, IntMultOp);
                    0x5: clmul({{
                        Rd = 0;
                        for (int i = 0; i < 64; i++) {
                            if ((Rs2 >> i) & 1) {
                                Rd ^= Rs1 << i;
                            }
                        }
                    }});
                    0x14: bset({{
                        Rs2 &= (64 - 1);
                        Rd = Rs1 | (UINT64_C(1) << Rs2);
                    }});
                    0x24: bclr({{
                        Rs2 &= (64 - 1);
                        Rd = Rs1 & (~(UINT64_C(1) << Rs2));
                    }});
                    0x30: rol({{
                        int shamt = Rs2 & (64 - 1);
                        Rd = (Rs1 << shamt) | (Rs1 >> ((64 - shamt) & (64 - 1)));
                    }});
                    0x34: binv({{
                        Rs2 &= (64 - 1);
                        Rd = Rs1 ^ (UINT64_C(1) << Rs2);
                    }});
                }
                0x2: decode FUNCT7 {
                    0x0: slt({{
                        Rd = (Rs1_sd < Rs2_sd) ? 1 : 0;
                    }});
                    0x1: mulhsu({{
                        bool negate = Rs1_sd < 0;
                        uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                        uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                        uint64_t Rs2_lo = (uint32_t)Rs2;
                        uint64_t Rs2_hi = Rs2 >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs1_lo*Rs2_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        uint64_t res = hi +
                                       (mid1 >> 32) +
                                       (mid2 >> 32) +
                                       carry;
                        Rd = negate ? ~res + (Rs1_sd*Rs2 == 0 ? 1 : 0) : res;
                    }}, IntMultOp);
                    0x5: clmulr({{
                        Rd = 0;
                        for (int i = 0; i < 64; i++) {
                            if ((Rs2 >> i) & 1) {
                                Rd ^= Rs1 >> (64-i-1);
                            }
                        }
                    }});
                    0x10: sh1add({{
                        Rd = (Rs1 << 1) + Rs2;
                    }});
                }
                0x3: decode FUNCT7 {
                    0x0: sltu({{
                        Rd = (Rs1 < Rs2) ? 1 : 0;
                    }});
                    0x1: mulhu({{
                        uint64_t Rs1_lo = (uint32_t)Rs1;
                        uint64_t Rs1_hi = Rs1 >> 32;
                        uint64_t Rs2_lo = (uint32_t)Rs2;
                        uint64_t Rs2_hi = Rs2 >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs1_lo*Rs2_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        Rd = hi + (mid1 >> 32) + (mid2 >> 32) + carry;
                    }}, IntMultOp);
                    0x5: clmulh({{
                        Rd = 0;
                        for (int i = 1; i < 64; i++) {
                            if ((Rs2 >> i) & 1) {
                                Rd ^= (Rs1 >> (64-i));
                            }
                        }
                    }});
                }
                0x4: decode FUNCT7 {
                    0x0: xor({{
                        Rd = Rs1 ^ Rs2;
                    }});
                    0x1: div({{
                        if (Rs2_sd == 0) {
                            Rd_sd = -1;
                        } else if (
                                Rs1_sd == std::numeric_limits<int64_t>::min()
                                && Rs2_sd == -1) {
                            Rd_sd = std::numeric_limits<int64_t>::min();
                        } else {
                            Rd_sd = Rs1_sd/Rs2_sd;
                        }
                    }}, IntDivOp);
                    0x5: min({{
                        Rd = (((int64_t) Rs1) < ((int64_t) Rs2)) ? Rs1 : Rs2;
                    }});
                    0x10: sh2add({{
                        Rd = (Rs1 << 2) + Rs2;
                    }});
                    0x20: xnor({{
                        Rd = ~(Rs1 ^ Rs2);
                    }});
                }
                0x5: decode FUNCT7 {
                    0x0: srl({{
                        Rd = Rs1 >> Rs2<5:0>;
                    }});
                    0x1: divu({{
                        if (Rs2 == 0) {
                            Rd = std::numeric_limits<uint64_t>::max();
                        } else {
                            Rd = Rs1/Rs2;
                        }
                    }}, IntDivOp);
                    0x20: sra({{
                        Rd_sd = Rs1_sd >> Rs2<5:0>;
                    }});
                    0x5: minu({{
                        Rd = Rs1 < Rs2 ? Rs1 : Rs2;
                    }});
                    0x24: bext({{
                        Rs2 &= (64 - 1);
                        Rd = (Rs1 >> Rs2) & 0x1;
                    }});
                    0x30: ror({{
                        int shamt = Rs2 & (64 - 1);
                        Rd = (Rs1 >> shamt) | (Rs1 << ((64 - shamt) & (64 - 1)));
                    }});
                }
                0x6: decode FUNCT7 {
                    0x0: or({{
                        Rd = Rs1 | Rs2;
                    }});
                    0x1: rem({{
                        if (Rs2_sd == 0) {
                            Rd = Rs1_sd;
                        } else if (
                                Rs1_sd == std::numeric_limits<int64_t>::min()
                                && Rs2_sd == -1) {
                            Rd = 0;
                        } else {
                            Rd = Rs1_sd%Rs2_sd;
                        }
                    }}, IntDivOp);
                    0x5: max({{
                        Rd = (((int64_t) Rs1) > ((int64_t) Rs2)) ? Rs1 : Rs2;
                    }});
                    0x10: sh3add({{
                        Rd = (Rs1 << 3) + Rs2;
                    }});
                    0x20: orn({{
                        Rd = Rs1 | (~Rs2);
                    }});
                }
                0x7: decode FUNCT7 {
                    0x0: and({{
                        Rd = Rs1 & Rs2;
                    }});
                    0x1: remu({{
                        if (Rs2 == 0) {
                            Rd = Rs1;
                        } else {
                            Rd = Rs1%Rs2;
                        }
                    }}, IntDivOp);
                    0x5: maxu({{
                        Rd = Rs1 > Rs2 ? Rs1 : Rs2;
                    }});
                    0x20: andn({{
                        Rd = Rs1 & (~Rs2);
                    }});
                }
            }
        }

        0x0d: UOp::lui({{
            using namespace gem5::RiscvcapstoneISA::o3;

            DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
            assert(dyn_inst);

            if(Rd_trv.getTag()) {
                Rd_trv.setTag(false);
                NodeID node_id = Rd_trv.getRegVal().capVal().nodeId();
                dyn_inst->initiateNodeCommand(new NodeRcUpdate(node_id, -1));
            }

            Rd_trv.getRegVal().intVal() = (uint64_t)(sext<20>(imm) << 12);

            Rd_trv = Rd_trv;
        }});

        0x0e: decode FUNCT3 {
            format ROp {
                0x0: decode FUNCT7 {
                    0x0: addw({{
                        Rd_sd = Rs1_sw + Rs2_sw;
                    }});
                    0x1: mulw({{
                        Rd_sd = (int32_t)(Rs1_sw*Rs2_sw);
                    }}, IntMultOp);
                    0x4: adduw({{
                        Rd = Rs1_uw + Rs2;
                    }});
                    0x20: subw({{
                        Rd_sd = Rs1_sw - Rs2_sw;
                    }});
                }
                0x1: decode FUNCT7 {
                    0x0: sllw({{
                        Rd_sd = Rs1_sw << Rs2<4:0>;
                    }});
                    0x30: rolw({{
                        int shamt = Rs2 & (32 - 1);
                        Rd = (int32_t) ((Rs1_uw << shamt) | (Rs1_uw >> ((32 - shamt) & (32 - 1))));
                    }});
                }
                0x2: decode FUNCT7 {
                    0x10: sh1adduw({{
                        Rd = (((uint64_t)Rs1_uw) << 1) + Rs2;
                    }});
                }
                0x4: decode FUNCT7 {
                    0x1: divw({{
                        if (Rs2_sw == 0) {
                            Rd_sd = -1;
                        } else if (Rs1_sw == std::numeric_limits<int32_t>::min()
                                && Rs2_sw == -1) {
                            Rd_sd = std::numeric_limits<int32_t>::min();
                        } else {
                            Rd_sd = Rs1_sw/Rs2_sw;
                        }
                    }}, IntDivOp);
                    0x4: zexth ({{
                        Rd = Rs1_uh;
                    }});
                    0x10: sh2adduw({{
                        Rd = (((uint64_t)Rs1_uw) << 2) + Rs2;
                    }});
                }
                0x5: decode FUNCT7 {
                    0x0: srlw({{
                        Rd_sd = (int32_t)(Rs1_uw >> Rs2<4:0>);
                    }});
                    0x1: divuw({{
                        if (Rs2_uw == 0) {
                            Rd_sd = std::numeric_limits<uint64_t>::max();
                        } else {
                            Rd_sd = (int32_t)(Rs1_uw/Rs2_uw);
                        }
                    }}, IntDivOp);
                    0x20: sraw({{
                        Rd_sd = Rs1_sw >> Rs2<4:0>;
                    }});
                    0x30: rorw({{
                        int shamt = Rs2 & (32 - 1);
                        Rd = (int32_t) ((Rs1_uw >> shamt) | (Rs1_uw << ((32 - shamt) & (32 - 1))));
                    }});
                }
                0x6:  decode FUNCT7 {
                    0x1: remw({{
                        if (Rs2_sw == 0) {
                            Rd_sd = Rs1_sw;
                        } else if (Rs1_sw == std::numeric_limits<int32_t>::min()
                                && Rs2_sw == -1) {
                            Rd_sd = 0;
                        } else {
                            Rd_sd = Rs1_sw%Rs2_sw;
                        }
                    }}, IntDivOp);
                    0x10: sh3adduw({{
                        Rd = (((uint64_t)Rs1_uw) << 3) + Rs2;
                    }});
                }
                0x7: remuw({{
                    if (Rs2_uw == 0) {
                        Rd_sd = (int32_t)Rs1_uw;
                    } else {
                        Rd_sd = (int32_t)(Rs1_uw%Rs2_uw);
                    }
                }}, IntDivOp);
            }
        }

        format FPROp {
            0x10: decode FUNCT2 {
                0x0: fmadd_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),
                                         f32(freg(Fs2_bits)),
                                         f32(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x1: fmadd_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),
                                         f64(freg(Fs2_bits)),
                                         f64(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x2: fmadd_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),
                                         f16(freg(Fs2_bits)),
                                         f16(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
            }
            0x11: decode FUNCT2 {
                0x0: fmsub_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),
                                    f32(freg(Fs2_bits)),
                                    f32(f32(freg(Fs3_bits)).v ^
                                        mask(31, 31))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x1: fmsub_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),
                                    f64(freg(Fs2_bits)),
                                    f64(f64(freg(Fs3_bits)).v ^
                                        mask(63, 63))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x2: fmsub_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),
                                    f16(freg(Fs2_bits)),
                                    f16(f16(freg(Fs3_bits)).v ^
                                        mask(15, 15))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
            }
            0x12: decode FUNCT2 {
                0x0: fnmsub_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^
                                             mask(31, 31)),
                                         f32(freg(Fs2_bits)),
                                         f32(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x1: fnmsub_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^
                                             mask(63, 63)),
                                         f64(freg(Fs2_bits)),
                                         f64(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x2: fnmsub_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^
                                             mask(15, 15)),
                                         f16(freg(Fs2_bits)),
                                         f16(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
            }
            0x13: decode FUNCT2 {
                0x0: fnmadd_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^
                                             mask(31, 31)),
                                    f32(freg(Fs2_bits)),
                                    f32(f32(freg(Fs3_bits)).v ^
                                        mask(31, 31))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x1: fnmadd_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^
                                             mask(63, 63)),
                                    f64(freg(Fs2_bits)),
                                    f64(f64(freg(Fs3_bits)).v ^
                                        mask(63, 63))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
                0x2: fnmadd_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^
                                             mask(15, 15)),
                                    f16(freg(Fs2_bits)),
                                    f16(f16(freg(Fs3_bits)).v ^
                                        mask(15, 15))));
                    Fd_bits = fd.v;
                }}, FloatMultAccOp);
            }
            0x14: decode FUNCT7 {
                0x0: fadd_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_add(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x1: fadd_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_add(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x2: fadd_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_add(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x4: fsub_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_sub(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x5: fsub_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_sub(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x6: fsub_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_sub(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatAddOp);
                0x8: fmul_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mul(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultOp);
                0x9: fmul_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mul(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultOp);
                0xa: fmul_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mul(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatMultOp);
                0xc: fdiv_s({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_div(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatDivOp);
                0xd: fdiv_d({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_div(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatDivOp);
                0xe: fdiv_h({{
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_div(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                }}, FloatDivOp);
                0x10: decode ROUND_MODE {
                    0x0: fsgnj_s({{
                        auto sign = bits(unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        }}, FloatMiscOp);
                    0x1: fsgnjn_s({{
                        auto sign = ~bits(unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        }}, FloatMiscOp);
                    0x2: fsgnjx_s({{
                        auto sign = bits(
                            unboxF32(Fs1_bits) ^ unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        }}, FloatMiscOp);
                }
                0x11: decode ROUND_MODE {
                    0x0: fsgnj_d({{
                        Fd_bits = insertBits(Fs2_bits, 62, 0, Fs1_bits);
                    }}, FloatMiscOp);
                    0x1: fsgnjn_d({{
                        Fd_bits = insertBits(~Fs2_bits, 62, 0, Fs1_bits);
                    }}, FloatMiscOp);
                    0x2: fsgnjx_d({{
                        Fd_bits = insertBits(
                                Fs1_bits ^ Fs2_bits, 62, 0, Fs1_bits);
                    }}, FloatMiscOp);
                }
                0x12: decode ROUND_MODE {
                    0x0: fsgnj_h({{
                        auto sign = bits(unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        }}, FloatMiscOp);
                    0x1: fsgnjn_h({{
                        auto sign = ~bits(unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        }}, FloatMiscOp);
                    0x2: fsgnjx_h({{
                        auto sign = bits(
                            unboxF16(Fs1_bits) ^ unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        }}, FloatMiscOp);
                }
                0x14: decode ROUND_MODE {
                    0x0: fmin_s({{
                        bool less = f32_lt_quiet(f32(freg(Fs1_bits)),
                            f32(freg(Fs2_bits))) ||
                            (f32_eq(f32(freg(Fs1_bits)),
                            f32(freg(Fs2_bits))) &&
                            bits(f32(freg(Fs1_bits)).v, 31));

                        Fd_bits = less ||
                            isNaNF32UI(f32(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF32UI(f32(freg(Fs1_bits)).v) &&
                            isNaNF32UI(f32(freg(Fs2_bits)).v))
                            Fd_bits = f32(defaultNaNF32UI).v;
                        }}, FloatCmpOp);
                    0x1: fmax_s({{
                        bool greater = f32_lt_quiet(f32(freg(Fs2_bits)),
                            f32(freg(Fs1_bits))) ||
                            (f32_eq(f32(freg(Fs2_bits)),
                            f32(freg(Fs1_bits))) &&
                            bits(f32(freg(Fs2_bits)).v, 31));

                        Fd_bits = greater ||
                            isNaNF32UI(f32(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF32UI(f32(freg(Fs1_bits)).v) &&
                            isNaNF32UI(f32(freg(Fs2_bits)).v))
                            Fd_bits = f32(defaultNaNF32UI).v;
                        }}, FloatCmpOp);
                }
                0x15: decode ROUND_MODE {
                    0x0: fmin_d({{
                        bool less = f64_lt_quiet(f64(freg(Fs1_bits)),
                            f64(freg(Fs2_bits))) ||
                            (f64_eq(f64(freg(Fs1_bits)),
                            f64(freg(Fs2_bits))) &&
                            bits(f64(freg(Fs1_bits)).v, 63));

                        Fd_bits = less ||
                            isNaNF64UI(f64(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF64UI(f64(freg(Fs1_bits)).v) &&
                            isNaNF64UI(f64(freg(Fs2_bits)).v))
                            Fd_bits = f64(defaultNaNF64UI).v;
                    }}, FloatCmpOp);
                    0x1: fmax_d({{
                        bool greater =
                            f64_lt_quiet(f64(freg(Fs2_bits)),
                            f64(freg(Fs1_bits))) ||
                            (f64_eq(f64(freg(Fs2_bits)),
                            f64(freg(Fs1_bits))) &&
                            bits(f64(freg(Fs2_bits)).v, 63));

                        Fd_bits = greater ||
                            isNaNF64UI(f64(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF64UI(f64(freg(Fs1_bits)).v) &&
                            isNaNF64UI(f64(Fs2_bits).v))
                            Fd_bits = f64(defaultNaNF64UI).v;
                    }}, FloatCmpOp);
                }
                0x16: decode ROUND_MODE {
                    0x0: fmin_h({{
                        bool less = f16_lt_quiet(f16(freg(Fs1_bits)),
                            f16(freg(Fs2_bits))) ||
                            (f16_eq(f16(freg(Fs1_bits)),
                            f16(freg(Fs2_bits))) &&
                            bits(f16(freg(Fs1_bits)).v, 15));

                        Fd_bits = less ||
                            isNaNF16UI(f16(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF16UI(f16(freg(Fs1_bits)).v) &&
                            isNaNF16UI(f16(freg(Fs2_bits)).v))
                            Fd_bits = f16(defaultNaNF16UI).v;
                        }}, FloatCmpOp);
                    0x1: fmax_h({{
                        bool greater = f16_lt_quiet(f16(freg(Fs2_bits)),
                            f16(freg(Fs1_bits))) ||
                            (f16_eq(f16(freg(Fs2_bits)),
                            f16(freg(Fs1_bits))) &&
                            bits(f16(freg(Fs2_bits)).v, 15));

                        Fd_bits = greater ||
                            isNaNF16UI(f16(freg(Fs2_bits)).v) ?
                            freg(Fs1_bits).v : freg(Fs2_bits).v;
                        if (isNaNF16UI(f16(freg(Fs1_bits)).v) &&
                            isNaNF16UI(f16(freg(Fs2_bits)).v))
                            Fd_bits = f16(defaultNaNF16UI).v;
                        }}, FloatCmpOp);
                }
                0x20: decode CONV_SGN {
                    0x1: fcvt_s_d({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f64_to_f32(f64(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                    0x2: fcvt_s_h({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f16_to_f32(f16(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                }
                0x21: decode CONV_SGN {
                    0x0: fcvt_d_s({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f32_to_f64(f32(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                    0x2: fcvt_d_h({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f16_to_f64(f16(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                }
                0x22: decode CONV_SGN {
                    0x0: fcvt_h_s({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f32_to_f16(f32(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                    0x1: fcvt_h_d({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f64_to_f16(f64(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    }}, FloatCvtOp);
                }
                0x2c: fsqrt_s({{
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f32_sqrt(f32(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                }}, FloatSqrtOp);
                0x2d: fsqrt_d({{
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f64_sqrt(f64(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                }}, FloatSqrtOp);
                0x2e: fsqrt_h({{
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f16_sqrt(f16(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                }}, FloatSqrtOp);
                0x50: decode ROUND_MODE {
                    0x0: fle_s({{
                        Rd = f32_le(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x1: flt_s({{
                        Rd = f32_lt(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x2: feq_s({{
                        Rd = f32_eq(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                }
                0x51: decode ROUND_MODE {
                    0x0: fle_d({{
                        Rd = f64_le(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x1: flt_d({{
                        Rd = f64_lt(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x2: feq_d({{
                        Rd = f64_eq(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                }
                0x52: decode ROUND_MODE {
                    0x0: fle_h({{
                        Rd = f16_le(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x1: flt_h({{
                        Rd = f16_lt(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                    0x2: feq_h({{
                        Rd = f16_eq(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    }}, FloatCmpOp);
                }
                0x60: decode CONV_SGN {
                    0x0: fcvt_w_s({{
                        RM_REQUIRED;
                        Rd_sd = sext<32>(f32_to_i32(f32(freg(Fs1_bits)), rm,
                                                    true));
                    }}, FloatCvtOp);
                    0x1: fcvt_wu_s({{
                        RM_REQUIRED;
                        Rd = sext<32>(f32_to_ui32(f32(freg(Fs1_bits)), rm,
                                                  true));
                    }}, FloatCvtOp);
                    0x2: fcvt_l_s({{
                        RM_REQUIRED;
                        Rd_sd = f32_to_i64(f32(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                    0x3: fcvt_lu_s({{
                        RM_REQUIRED;
                        Rd = f32_to_ui64(f32(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                }
                0x61: decode CONV_SGN {
                    0x0: fcvt_w_d({{
                        RM_REQUIRED;
                        Rd_sd = sext<32>(f64_to_i32(f64(freg(Fs1_bits)), rm,
                                                    true));
                    }}, FloatCvtOp);
                    0x1: fcvt_wu_d({{
                        RM_REQUIRED;
                        Rd = sext<32>(f64_to_ui32(f64(freg(Fs1_bits)), rm,
                                                  true));
                    }}, FloatCvtOp);
                    0x2: fcvt_l_d({{
                        RM_REQUIRED;
                        Rd_sd = f64_to_i64(f64(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                    0x3: fcvt_lu_d({{
                        RM_REQUIRED;
                        Rd = f64_to_ui64(f64(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                }
                0x62: decode CONV_SGN {
                    0x0: fcvt_w_h({{
                        RM_REQUIRED;
                        Rd_sd = sext<32>(f16_to_i32(f16(freg(Fs1_bits)), rm,
                                                    true));
                    }}, FloatCvtOp);
                    0x1: fcvt_wu_h({{
                        RM_REQUIRED;
                        Rd = sext<32>(f16_to_ui32(f16(freg(Fs1_bits)), rm,
                                                  true));
                    }}, FloatCvtOp);
                    0x2: fcvt_l_h({{
                        RM_REQUIRED;
                        Rd_sd = f16_to_i64(f16(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                    0x3: fcvt_lu_h({{
                        RM_REQUIRED;
                        Rd = f16_to_ui64(f16(freg(Fs1_bits)), rm, true);
                    }}, FloatCvtOp);
                }
                0x68: decode CONV_SGN {
                    0x0: fcvt_s_w({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i32_to_f32((int32_t)Rs1_sw));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x1: fcvt_s_wu({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui32_to_f32((uint32_t)Rs1_uw));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x2: fcvt_s_l({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i64_to_f32(Rs1_ud));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x3: fcvt_s_lu({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui64_to_f32(Rs1));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                }
                0x69: decode CONV_SGN {
                    0x0: fcvt_d_w({{
                        RM_REQUIRED;
                        Fd = (double)Rs1_sw;
                    }}, FloatCvtOp);
                    0x1: fcvt_d_wu({{
                        RM_REQUIRED;
                        Fd = (double)Rs1_uw;
                    }}, FloatCvtOp);
                    0x2: fcvt_d_l({{
                        RM_REQUIRED;
                        Fd = (double)Rs1_sd;
                    }}, FloatCvtOp);
                    0x3: fcvt_d_lu({{
                        RM_REQUIRED;
                        Fd = (double)Rs1;
                    }}, FloatCvtOp);
                }
                0x6a: decode CONV_SGN {
                    0x0: fcvt_h_w({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i32_to_f16((int32_t)Rs1_sw));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x1: fcvt_h_wu({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui32_to_f16((uint32_t)Rs1_uw));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x2: fcvt_h_l({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i64_to_f16(Rs1_ud));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                    0x3: fcvt_h_lu({{
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui64_to_f16(Rs1));
                        Fd_bits = fd.v;
                        }}, FloatCvtOp);
                }
                0x70: decode ROUND_MODE {
                    0x0: fmv_x_w({{
                        Rd = (uint32_t)Fs1_bits;
                        if ((Rd&0x80000000) != 0) {
                            Rd |= (0xFFFFFFFFULL << 32);
                        }
                    }}, FloatCvtOp);
                    0x1: fclass_s({{
                        Rd = f32_classify(f32(freg(Fs1_bits)));
                    }}, FloatMiscOp);
                }
                0x71: decode ROUND_MODE {
                    0x0: fmv_x_d({{
                        Rd = freg(Fs1_bits).v;
                    }}, FloatCvtOp);
                    0x1: fclass_d({{
                        Rd = f64_classify(f64(freg(Fs1_bits)));
                    }}, FloatMiscOp);
                }
                0x72: decode ROUND_MODE {
                    0x0: fmv_x_h({{
                        Rd = (uint16_t)Fs1_bits;
                        if ((Rd&0x8000) != 0) {
                            Rd |= (0xFFFFFFFFFFFFULL << 16);
                        }
                    }}, FloatCvtOp);
                    0x1: fclass_h({{
                        Rd = f16_classify(f16(freg(Fs1_bits)));
                    }}, FloatMiscOp);
                }
                0x78: fmv_w_x({{
                    freg_t fd;
                    fd = freg(f32(Rs1_uw));
                    Fd_bits = fd.v;
                }}, FloatCvtOp);
                0x79: fmv_d_x({{
                    freg_t fd;
                    fd = freg(f64(Rs1));
                    Fd_bits = fd.v;
                }}, FloatCvtOp);
                0x7a: fmv_h_x({{
                    freg_t fd;
                    fd = freg(f16(Rs1_uh));
                    Fd_bits = fd.v;
                }}, FloatCvtOp);
            }
        }

        0x18: decode FUNCT3 {
            format BOp {
                0x0: beq({{
                    if (Rs1 == Rs2) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x1: bne({{
                    if (Rs1 != Rs2) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x4: blt({{
                    if (Rs1_sd < Rs2_sd) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x5: bge({{
                    if (Rs1_sd >= Rs2_sd) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x6: bltu({{
                    if (Rs1 < Rs2) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x7: bgeu({{
                    if (Rs1 >= Rs2) {
                        if(dyn_inst->isSecureWorld()) {
                            Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                            pc_cap.setCursor(PC + imm);
                            dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                        }
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
            }
        }

        0x19: decode FUNCT3 {
            0x0: Jump::jalr({{
                using namespace gem5::RiscvcapstoneISA::o3;

                DynInst* dyn_inst = dynamic_cast<DynInst*>(xc);
                assert(dyn_inst);

                Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                ConstTaggedRegVal temp_regval;

                if(dyn_inst->isSecureWorld()) {
                    pc_cap.setCursor(NPC);
                    temp_regval.setTag(true);
                    temp_regval.getRegVal().rawCapVal() = (uint128_t)pc_cap;
                } else {
                    temp_regval.setTag(false);
                    temp_regval.getRegVal().intVal() = NPC;
                }

                NPC = (imm + Rs1) & (~0x1);
                Rd_trv = temp_regval;

                if(dyn_inst->isSecureWorld()) {
                    pc_cap.setCursor(NPC);
                    dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                }
            }}, IsIndirectControl, IsUncondControl);
        }

        0x1b: JOp::jal({{
                Cap pc_cap = dyn_inst->cpu->getIEWObject().getPCCap(dyn_inst->threadNumber);
                ConstTaggedRegVal temp_regval;

                if(dyn_inst->isSecureWorld()) {
                    pc_cap.setCursor(NPC);
                    temp_regval.setTag(true);
                    temp_regval.getRegVal().rawCapVal() = (uint128_t)pc_cap;
                } else {
                    temp_regval.setTag(false);
                    temp_regval.getRegVal().intVal() = NPC;
                }

                NPC = PC + imm;
                Rd_trv = temp_regval;

                if(dyn_inst->isSecureWorld()) {
                    pc_cap.setCursor(NPC);
                    dyn_inst->cpu->getIEWObject().setPCCap(pc_cap, dyn_inst->threadNumber);
                }
        }}, IsDirectControl, IsUncondControl);

        0x1c: decode FUNCT3 {
            format SystemOp {
                0x0: decode FUNCT7 {
                    0x0: decode RS2 {
                        0x0: EcallOp::ecall({{
                            return std::make_shared<SyscallFault>(
                                (PrivilegeMode)xc->readMiscReg(MISCREG_PRV).intVal());
                        }}, IsSerializeAfter, IsNonSpeculative, IsSyscall,
                            No_OpClass);
                        0x1: ebreak({{
                            return std::make_shared<BreakpointFault>(
                                xc->pcState());
                        }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                        0x2: uret({{
                            STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                            status.uie = status.upie;
                            status.upie = 1;
                            xc->setMiscReg(MISCREG_STATUS, static_cast<uint64_t>(status));
                            NPC = xc->readMiscReg(MISCREG_UEPC).intVal();
                        }}, IsSerializeAfter, IsNonSpeculative, IsReturn);
                    }
                    0x8: decode RS2 {
                        0x2: sret({{
                            STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                            auto pm = (PrivilegeMode)(xc->readMiscReg(
                                MISCREG_PRV).intVal());
                            if (pm == PRV_U ||
                                (pm == PRV_S && status.tsr == 1)) {
                                return std::make_shared<IllegalInstFault>(
                                            "sret in user mode or TSR enabled",
                                            machInst);
                                NPC = NPC;
                            } else {
                                xc->setMiscReg(MISCREG_PRV, static_cast<uint64_t>(status.spp));
                                status.sie = status.spie;
                                status.spie = 1;
                                status.spp = PRV_U;
                                xc->setMiscReg(MISCREG_STATUS, static_cast<uint64_t>(status));
                                NPC = xc->readMiscReg(MISCREG_SEPC).intVal();
                            }
                        }}, IsSerializeAfter, IsNonSpeculative, IsReturn);
                        0x5: wfi({{
                            STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                            auto pm = (PrivilegeMode)(xc->readMiscReg(
                                MISCREG_PRV).intVal());
                            if (pm == PRV_U ||
                                (pm == PRV_S && status.tw == 1)) {
                                return std::make_shared<IllegalInstFault>(
                                            "wfi in user mode or TW enabled",
                                            machInst);
                            }
                            // don't do anything for now
                        }}, No_OpClass);
                    }
                    0x9: sfence_vma({{
                        STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV).intVal();
                        if (pm == PRV_U || (pm == PRV_S && status.tvm == 1)) {
                            return std::make_shared<IllegalInstFault>(
                                        "sfence in user mode or TVM enabled",
                                        machInst);
                        }
                        xc->tcBase()->getMMUPtr()->demapPage(Rs1, Rs2);
                    }}, IsNonSpeculative, IsSerializeAfter, No_OpClass);
                    0x18: mret({{
                        if (xc->readMiscReg(MISCREG_PRV).intVal() != PRV_M) {
                            return std::make_shared<IllegalInstFault>(
                                        "mret at lower privilege", machInst);
                            NPC = NPC;
                        } else {
                            STATUS status = xc->readMiscReg(MISCREG_STATUS).intVal();
                            xc->setMiscReg(MISCREG_PRV, static_cast<uint64_t>(status.mpp));
                            xc->setMiscReg(MISCREG_NMIE, static_cast<uint64_t>(1));
                            status.mie = status.mpie;
                            status.mpie = 1;
                            status.mpp = PRV_U;
                            xc->setMiscReg(MISCREG_STATUS, static_cast<uint64_t>(status));
                            NPC = xc->readMiscReg(MISCREG_MEPC).intVal();
                        }
                    }}, IsSerializeAfter, IsNonSpeculative, IsReturn);
                }
            }
            format CSROp {
                0x1: csrrw({{
                    Rd = data;
                    data = Rs1;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                0x2: csrrs({{
                    Rd = data;
                    data |= Rs1;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                0x3: csrrc({{
                    Rd = data;
                    data &= ~Rs1;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                0x5: csrrwi({{
                    Rd = data;
                    data = uimm;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                0x6: csrrsi({{
                    Rd = data;
                    data |= uimm;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
                0x7: csrrci({{
                    Rd = data;
                    data &= ~uimm;
                }}, IsSerializeAfter, IsNonSpeculative, No_OpClass);
            }
        }

        0x1e: M5Op::M5Op();
    }
}
